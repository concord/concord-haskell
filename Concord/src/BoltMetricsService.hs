{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.2)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module BoltMetricsService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Bolt_Types
import qualified BoltMetricsService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data Gauge_args = Gauge_args  { gauge_args_name :: LT.Text
  , gauge_args_val :: I.Int64
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Gauge_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` gauge_args_name record   `H.hashWithSalt` gauge_args_val record  
instance QC.Arbitrary Gauge_args where 
  arbitrary = M.liftM Gauge_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Gauge_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Gauge_args{gauge_args_name = gauge_args_name obj} then P.Nothing else P.Just $ default_Gauge_args{gauge_args_name = gauge_args_name obj}
    , if obj == default_Gauge_args{gauge_args_val = gauge_args_val obj} then P.Nothing else P.Just $ default_Gauge_args{gauge_args_val = gauge_args_val obj}
    ]
from_Gauge_args :: Gauge_args -> T.ThriftVal
from_Gauge_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v410 -> P.Just (1, ("name",T.TString $ E.encodeUtf8 _v410))) $ gauge_args_name record
  , (\_v410 -> P.Just (2, ("val",T.TI64 _v410))) $ gauge_args_val record
  ]
write_Gauge_args :: (T.Protocol p, T.Transport t) => p t -> Gauge_args -> P.IO ()
write_Gauge_args oprot record = T.writeVal oprot $ from_Gauge_args record
encode_Gauge_args :: (T.Protocol p, T.Transport t) => p t -> Gauge_args -> LBS.ByteString
encode_Gauge_args oprot record = T.serializeVal oprot $ from_Gauge_args record
to_Gauge_args :: T.ThriftVal -> Gauge_args
to_Gauge_args (T.TStruct fields) = Gauge_args{
  gauge_args_name = P.maybe (gauge_args_name default_Gauge_args) (\(_,_val412) -> (case _val412 of {T.TString _val413 -> E.decodeUtf8 _val413; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  gauge_args_val = P.maybe (gauge_args_val default_Gauge_args) (\(_,_val412) -> (case _val412 of {T.TI64 _val414 -> _val414; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Gauge_args _ = P.error "not a struct"
read_Gauge_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Gauge_args
read_Gauge_args iprot = to_Gauge_args <$> T.readVal iprot (T.T_STRUCT typemap_Gauge_args)
decode_Gauge_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Gauge_args
decode_Gauge_args iprot bs = to_Gauge_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Gauge_args) bs
typemap_Gauge_args :: T.TypeMap
typemap_Gauge_args = Map.fromList [(1,("name",T.T_STRING)),(2,("val",T.T_I64))]
default_Gauge_args :: Gauge_args
default_Gauge_args = Gauge_args{
  gauge_args_name = "",
  gauge_args_val = 0}
data Gauge_result = Gauge_result  { gauge_result_e :: P.Maybe BoltError
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Gauge_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` gauge_result_e record  
instance QC.Arbitrary Gauge_result where 
  arbitrary = M.liftM Gauge_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Gauge_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Gauge_result{gauge_result_e = gauge_result_e obj} then P.Nothing else P.Just $ default_Gauge_result{gauge_result_e = gauge_result_e obj}
    ]
from_Gauge_result :: Gauge_result -> T.ThriftVal
from_Gauge_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v417 -> (1, ("e",from_BoltError _v417))) <$> gauge_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v417 -> (1, ("e",from_BoltError _v417))) <$> gauge_result_e record
    ]
    )
write_Gauge_result :: (T.Protocol p, T.Transport t) => p t -> Gauge_result -> P.IO ()
write_Gauge_result oprot record = T.writeVal oprot $ from_Gauge_result record
encode_Gauge_result :: (T.Protocol p, T.Transport t) => p t -> Gauge_result -> LBS.ByteString
encode_Gauge_result oprot record = T.serializeVal oprot $ from_Gauge_result record
to_Gauge_result :: T.ThriftVal -> Gauge_result
to_Gauge_result (T.TStruct fields) = Gauge_result{
  gauge_result_e = P.maybe (P.Nothing) (\(_,_val419) -> P.Just (case _val419 of {T.TStruct _val420 -> (to_BoltError (T.TStruct _val420)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Gauge_result _ = P.error "not a struct"
read_Gauge_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Gauge_result
read_Gauge_result iprot = to_Gauge_result <$> T.readVal iprot (T.T_STRUCT typemap_Gauge_result)
decode_Gauge_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Gauge_result
decode_Gauge_result iprot bs = to_Gauge_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Gauge_result) bs
typemap_Gauge_result :: T.TypeMap
typemap_Gauge_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_BoltError)))]
default_Gauge_result :: Gauge_result
default_Gauge_result = Gauge_result{
  gauge_result_e = P.Nothing}
data Timer_args = Timer_args  { timer_args_name :: LT.Text
  , timer_args_duration :: I.Int64
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Timer_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timer_args_name record   `H.hashWithSalt` timer_args_duration record  
instance QC.Arbitrary Timer_args where 
  arbitrary = M.liftM Timer_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Timer_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Timer_args{timer_args_name = timer_args_name obj} then P.Nothing else P.Just $ default_Timer_args{timer_args_name = timer_args_name obj}
    , if obj == default_Timer_args{timer_args_duration = timer_args_duration obj} then P.Nothing else P.Just $ default_Timer_args{timer_args_duration = timer_args_duration obj}
    ]
from_Timer_args :: Timer_args -> T.ThriftVal
from_Timer_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v423 -> P.Just (1, ("name",T.TString $ E.encodeUtf8 _v423))) $ timer_args_name record
  , (\_v423 -> P.Just (2, ("duration",T.TI64 _v423))) $ timer_args_duration record
  ]
write_Timer_args :: (T.Protocol p, T.Transport t) => p t -> Timer_args -> P.IO ()
write_Timer_args oprot record = T.writeVal oprot $ from_Timer_args record
encode_Timer_args :: (T.Protocol p, T.Transport t) => p t -> Timer_args -> LBS.ByteString
encode_Timer_args oprot record = T.serializeVal oprot $ from_Timer_args record
to_Timer_args :: T.ThriftVal -> Timer_args
to_Timer_args (T.TStruct fields) = Timer_args{
  timer_args_name = P.maybe (timer_args_name default_Timer_args) (\(_,_val425) -> (case _val425 of {T.TString _val426 -> E.decodeUtf8 _val426; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timer_args_duration = P.maybe (timer_args_duration default_Timer_args) (\(_,_val425) -> (case _val425 of {T.TI64 _val427 -> _val427; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Timer_args _ = P.error "not a struct"
read_Timer_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Timer_args
read_Timer_args iprot = to_Timer_args <$> T.readVal iprot (T.T_STRUCT typemap_Timer_args)
decode_Timer_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Timer_args
decode_Timer_args iprot bs = to_Timer_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Timer_args) bs
typemap_Timer_args :: T.TypeMap
typemap_Timer_args = Map.fromList [(1,("name",T.T_STRING)),(2,("duration",T.T_I64))]
default_Timer_args :: Timer_args
default_Timer_args = Timer_args{
  timer_args_name = "",
  timer_args_duration = 0}
data Timer_result = Timer_result  { timer_result_e :: P.Maybe BoltError
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Timer_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` timer_result_e record  
instance QC.Arbitrary Timer_result where 
  arbitrary = M.liftM Timer_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Timer_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Timer_result{timer_result_e = timer_result_e obj} then P.Nothing else P.Just $ default_Timer_result{timer_result_e = timer_result_e obj}
    ]
from_Timer_result :: Timer_result -> T.ThriftVal
from_Timer_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v430 -> (1, ("e",from_BoltError _v430))) <$> timer_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v430 -> (1, ("e",from_BoltError _v430))) <$> timer_result_e record
    ]
    )
write_Timer_result :: (T.Protocol p, T.Transport t) => p t -> Timer_result -> P.IO ()
write_Timer_result oprot record = T.writeVal oprot $ from_Timer_result record
encode_Timer_result :: (T.Protocol p, T.Transport t) => p t -> Timer_result -> LBS.ByteString
encode_Timer_result oprot record = T.serializeVal oprot $ from_Timer_result record
to_Timer_result :: T.ThriftVal -> Timer_result
to_Timer_result (T.TStruct fields) = Timer_result{
  timer_result_e = P.maybe (P.Nothing) (\(_,_val432) -> P.Just (case _val432 of {T.TStruct _val433 -> (to_BoltError (T.TStruct _val433)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Timer_result _ = P.error "not a struct"
read_Timer_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Timer_result
read_Timer_result iprot = to_Timer_result <$> T.readVal iprot (T.T_STRUCT typemap_Timer_result)
decode_Timer_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Timer_result
decode_Timer_result iprot bs = to_Timer_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Timer_result) bs
typemap_Timer_result :: T.TypeMap
typemap_Timer_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_BoltError)))]
default_Timer_result :: Timer_result
default_Timer_result = Timer_result{
  timer_result_e = P.Nothing}
data Histogram_args = Histogram_args  { histogram_args_name :: LT.Text
  , histogram_args_measure :: I.Int64
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Histogram_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` histogram_args_name record   `H.hashWithSalt` histogram_args_measure record  
instance QC.Arbitrary Histogram_args where 
  arbitrary = M.liftM Histogram_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Histogram_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Histogram_args{histogram_args_name = histogram_args_name obj} then P.Nothing else P.Just $ default_Histogram_args{histogram_args_name = histogram_args_name obj}
    , if obj == default_Histogram_args{histogram_args_measure = histogram_args_measure obj} then P.Nothing else P.Just $ default_Histogram_args{histogram_args_measure = histogram_args_measure obj}
    ]
from_Histogram_args :: Histogram_args -> T.ThriftVal
from_Histogram_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v436 -> P.Just (1, ("name",T.TString $ E.encodeUtf8 _v436))) $ histogram_args_name record
  , (\_v436 -> P.Just (2, ("measure",T.TI64 _v436))) $ histogram_args_measure record
  ]
write_Histogram_args :: (T.Protocol p, T.Transport t) => p t -> Histogram_args -> P.IO ()
write_Histogram_args oprot record = T.writeVal oprot $ from_Histogram_args record
encode_Histogram_args :: (T.Protocol p, T.Transport t) => p t -> Histogram_args -> LBS.ByteString
encode_Histogram_args oprot record = T.serializeVal oprot $ from_Histogram_args record
to_Histogram_args :: T.ThriftVal -> Histogram_args
to_Histogram_args (T.TStruct fields) = Histogram_args{
  histogram_args_name = P.maybe (histogram_args_name default_Histogram_args) (\(_,_val438) -> (case _val438 of {T.TString _val439 -> E.decodeUtf8 _val439; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  histogram_args_measure = P.maybe (histogram_args_measure default_Histogram_args) (\(_,_val438) -> (case _val438 of {T.TI64 _val440 -> _val440; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Histogram_args _ = P.error "not a struct"
read_Histogram_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Histogram_args
read_Histogram_args iprot = to_Histogram_args <$> T.readVal iprot (T.T_STRUCT typemap_Histogram_args)
decode_Histogram_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Histogram_args
decode_Histogram_args iprot bs = to_Histogram_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Histogram_args) bs
typemap_Histogram_args :: T.TypeMap
typemap_Histogram_args = Map.fromList [(1,("name",T.T_STRING)),(2,("measure",T.T_I64))]
default_Histogram_args :: Histogram_args
default_Histogram_args = Histogram_args{
  histogram_args_name = "",
  histogram_args_measure = 0}
data Histogram_result = Histogram_result  { histogram_result_e :: P.Maybe BoltError
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Histogram_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` histogram_result_e record  
instance QC.Arbitrary Histogram_result where 
  arbitrary = M.liftM Histogram_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Histogram_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Histogram_result{histogram_result_e = histogram_result_e obj} then P.Nothing else P.Just $ default_Histogram_result{histogram_result_e = histogram_result_e obj}
    ]
from_Histogram_result :: Histogram_result -> T.ThriftVal
from_Histogram_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v443 -> (1, ("e",from_BoltError _v443))) <$> histogram_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v443 -> (1, ("e",from_BoltError _v443))) <$> histogram_result_e record
    ]
    )
write_Histogram_result :: (T.Protocol p, T.Transport t) => p t -> Histogram_result -> P.IO ()
write_Histogram_result oprot record = T.writeVal oprot $ from_Histogram_result record
encode_Histogram_result :: (T.Protocol p, T.Transport t) => p t -> Histogram_result -> LBS.ByteString
encode_Histogram_result oprot record = T.serializeVal oprot $ from_Histogram_result record
to_Histogram_result :: T.ThriftVal -> Histogram_result
to_Histogram_result (T.TStruct fields) = Histogram_result{
  histogram_result_e = P.maybe (P.Nothing) (\(_,_val445) -> P.Just (case _val445 of {T.TStruct _val446 -> (to_BoltError (T.TStruct _val446)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Histogram_result _ = P.error "not a struct"
read_Histogram_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Histogram_result
read_Histogram_result iprot = to_Histogram_result <$> T.readVal iprot (T.T_STRUCT typemap_Histogram_result)
decode_Histogram_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Histogram_result
decode_Histogram_result iprot bs = to_Histogram_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Histogram_result) bs
typemap_Histogram_result :: T.TypeMap
typemap_Histogram_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_BoltError)))]
default_Histogram_result :: Histogram_result
default_Histogram_result = Histogram_result{
  histogram_result_e = P.Nothing}
data Sum_args = Sum_args  { sum_args_name :: LT.Text
  , sum_args_counter :: I.Int64
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Sum_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sum_args_name record   `H.hashWithSalt` sum_args_counter record  
instance QC.Arbitrary Sum_args where 
  arbitrary = M.liftM Sum_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Sum_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Sum_args{sum_args_name = sum_args_name obj} then P.Nothing else P.Just $ default_Sum_args{sum_args_name = sum_args_name obj}
    , if obj == default_Sum_args{sum_args_counter = sum_args_counter obj} then P.Nothing else P.Just $ default_Sum_args{sum_args_counter = sum_args_counter obj}
    ]
from_Sum_args :: Sum_args -> T.ThriftVal
from_Sum_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v449 -> P.Just (1, ("name",T.TString $ E.encodeUtf8 _v449))) $ sum_args_name record
  , (\_v449 -> P.Just (2, ("counter",T.TI64 _v449))) $ sum_args_counter record
  ]
write_Sum_args :: (T.Protocol p, T.Transport t) => p t -> Sum_args -> P.IO ()
write_Sum_args oprot record = T.writeVal oprot $ from_Sum_args record
encode_Sum_args :: (T.Protocol p, T.Transport t) => p t -> Sum_args -> LBS.ByteString
encode_Sum_args oprot record = T.serializeVal oprot $ from_Sum_args record
to_Sum_args :: T.ThriftVal -> Sum_args
to_Sum_args (T.TStruct fields) = Sum_args{
  sum_args_name = P.maybe (sum_args_name default_Sum_args) (\(_,_val451) -> (case _val451 of {T.TString _val452 -> E.decodeUtf8 _val452; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sum_args_counter = P.maybe (sum_args_counter default_Sum_args) (\(_,_val451) -> (case _val451 of {T.TI64 _val453 -> _val453; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Sum_args _ = P.error "not a struct"
read_Sum_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Sum_args
read_Sum_args iprot = to_Sum_args <$> T.readVal iprot (T.T_STRUCT typemap_Sum_args)
decode_Sum_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Sum_args
decode_Sum_args iprot bs = to_Sum_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Sum_args) bs
typemap_Sum_args :: T.TypeMap
typemap_Sum_args = Map.fromList [(1,("name",T.T_STRING)),(2,("counter",T.T_I64))]
default_Sum_args :: Sum_args
default_Sum_args = Sum_args{
  sum_args_name = "",
  sum_args_counter = 0}
data Sum_result = Sum_result  { sum_result_e :: P.Maybe BoltError
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Sum_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sum_result_e record  
instance QC.Arbitrary Sum_result where 
  arbitrary = M.liftM Sum_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Sum_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Sum_result{sum_result_e = sum_result_e obj} then P.Nothing else P.Just $ default_Sum_result{sum_result_e = sum_result_e obj}
    ]
from_Sum_result :: Sum_result -> T.ThriftVal
from_Sum_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v456 -> (1, ("e",from_BoltError _v456))) <$> sum_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v456 -> (1, ("e",from_BoltError _v456))) <$> sum_result_e record
    ]
    )
write_Sum_result :: (T.Protocol p, T.Transport t) => p t -> Sum_result -> P.IO ()
write_Sum_result oprot record = T.writeVal oprot $ from_Sum_result record
encode_Sum_result :: (T.Protocol p, T.Transport t) => p t -> Sum_result -> LBS.ByteString
encode_Sum_result oprot record = T.serializeVal oprot $ from_Sum_result record
to_Sum_result :: T.ThriftVal -> Sum_result
to_Sum_result (T.TStruct fields) = Sum_result{
  sum_result_e = P.maybe (P.Nothing) (\(_,_val458) -> P.Just (case _val458 of {T.TStruct _val459 -> (to_BoltError (T.TStruct _val459)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Sum_result _ = P.error "not a struct"
read_Sum_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Sum_result
read_Sum_result iprot = to_Sum_result <$> T.readVal iprot (T.T_STRUCT typemap_Sum_result)
decode_Sum_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Sum_result
decode_Sum_result iprot bs = to_Sum_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Sum_result) bs
typemap_Sum_result :: T.TypeMap
typemap_Sum_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_BoltError)))]
default_Sum_result :: Sum_result
default_Sum_result = Sum_result{
  sum_result_e = P.Nothing}
process_gauge (seqid, iprot, oprot, handler) = do
  args <- read_Gauge_args iprot
  (X.catch
    (X.catch
      (do
        Iface.gauge handler (gauge_args_name args) (gauge_args_val args)
        let res = default_Gauge_result
        T.writeMessageBegin oprot ("gauge", T.M_REPLY, seqid)
        write_Gauge_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Gauge_result{gauge_result_e = P.Just e}
        T.writeMessageBegin oprot ("gauge", T.M_REPLY, seqid)
        write_Gauge_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("gauge", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_timer (seqid, iprot, oprot, handler) = do
  args <- read_Timer_args iprot
  (X.catch
    (X.catch
      (do
        Iface.timer handler (timer_args_name args) (timer_args_duration args)
        let res = default_Timer_result
        T.writeMessageBegin oprot ("timer", T.M_REPLY, seqid)
        write_Timer_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Timer_result{timer_result_e = P.Just e}
        T.writeMessageBegin oprot ("timer", T.M_REPLY, seqid)
        write_Timer_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("timer", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_histogram (seqid, iprot, oprot, handler) = do
  args <- read_Histogram_args iprot
  (X.catch
    (X.catch
      (do
        Iface.histogram handler (histogram_args_name args) (histogram_args_measure args)
        let res = default_Histogram_result
        T.writeMessageBegin oprot ("histogram", T.M_REPLY, seqid)
        write_Histogram_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Histogram_result{histogram_result_e = P.Just e}
        T.writeMessageBegin oprot ("histogram", T.M_REPLY, seqid)
        write_Histogram_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("histogram", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_sum (seqid, iprot, oprot, handler) = do
  args <- read_Sum_args iprot
  (X.catch
    (X.catch
      (do
        Iface.sum handler (sum_args_name args) (sum_args_counter args)
        let res = default_Sum_result
        T.writeMessageBegin oprot ("sum", T.M_REPLY, seqid)
        write_Sum_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Sum_result{sum_result_e = P.Just e}
        T.writeMessageBegin oprot ("sum", T.M_REPLY, seqid)
        write_Sum_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("sum", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "gauge" -> process_gauge (seqid,iprot,oprot,handler)
  "timer" -> process_timer (seqid,iprot,oprot,handler)
  "histogram" -> process_histogram (seqid,iprot,oprot,handler)
  "sum" -> process_sum (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessageBegin oprot (name,T.M_EXCEPTION,seqid)
    T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
    T.writeMessageEnd oprot
    T.tFlush (T.getTransport oprot)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- T.readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  T.readMessageEnd iprot
  P.return P.True
