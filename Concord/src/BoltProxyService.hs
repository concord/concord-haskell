{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.2)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module BoltProxyService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import qualified MutableEphemeralStateService
import Bolt_Types
import qualified BoltProxyService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data UpdateTopology_args = UpdateTopology_args  { updateTopology_args_topology :: TopologyMetadata
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable UpdateTopology_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateTopology_args_topology record  
instance QC.Arbitrary UpdateTopology_args where 
  arbitrary = M.liftM UpdateTopology_args (QC.arbitrary)
  shrink obj | obj == default_UpdateTopology_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateTopology_args{updateTopology_args_topology = updateTopology_args_topology obj} then P.Nothing else P.Just $ default_UpdateTopology_args{updateTopology_args_topology = updateTopology_args_topology obj}
    ]
from_UpdateTopology_args :: UpdateTopology_args -> T.ThriftVal
from_UpdateTopology_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v296 -> P.Just (1, ("topology",from_TopologyMetadata _v296))) $ updateTopology_args_topology record
  ]
write_UpdateTopology_args :: (T.Protocol p, T.Transport t) => p t -> UpdateTopology_args -> P.IO ()
write_UpdateTopology_args oprot record = T.writeVal oprot $ from_UpdateTopology_args record
encode_UpdateTopology_args :: (T.Protocol p, T.Transport t) => p t -> UpdateTopology_args -> LBS.ByteString
encode_UpdateTopology_args oprot record = T.serializeVal oprot $ from_UpdateTopology_args record
to_UpdateTopology_args :: T.ThriftVal -> UpdateTopology_args
to_UpdateTopology_args (T.TStruct fields) = UpdateTopology_args{
  updateTopology_args_topology = P.maybe (updateTopology_args_topology default_UpdateTopology_args) (\(_,_val298) -> (case _val298 of {T.TStruct _val299 -> (to_TopologyMetadata (T.TStruct _val299)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateTopology_args _ = P.error "not a struct"
read_UpdateTopology_args :: (T.Transport t, T.Protocol p) => p t -> P.IO UpdateTopology_args
read_UpdateTopology_args iprot = to_UpdateTopology_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateTopology_args)
decode_UpdateTopology_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> UpdateTopology_args
decode_UpdateTopology_args iprot bs = to_UpdateTopology_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateTopology_args) bs
typemap_UpdateTopology_args :: T.TypeMap
typemap_UpdateTopology_args = Map.fromList [(1,("topology",(T.T_STRUCT typemap_TopologyMetadata)))]
default_UpdateTopology_args :: UpdateTopology_args
default_UpdateTopology_args = UpdateTopology_args{
  updateTopology_args_topology = default_TopologyMetadata}
data UpdateTopology_result = UpdateTopology_result  { updateTopology_result_e :: P.Maybe BoltError
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable UpdateTopology_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateTopology_result_e record  
instance QC.Arbitrary UpdateTopology_result where 
  arbitrary = M.liftM UpdateTopology_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateTopology_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateTopology_result{updateTopology_result_e = updateTopology_result_e obj} then P.Nothing else P.Just $ default_UpdateTopology_result{updateTopology_result_e = updateTopology_result_e obj}
    ]
from_UpdateTopology_result :: UpdateTopology_result -> T.ThriftVal
from_UpdateTopology_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v302 -> (1, ("e",from_BoltError _v302))) <$> updateTopology_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v302 -> (1, ("e",from_BoltError _v302))) <$> updateTopology_result_e record
    ]
    )
write_UpdateTopology_result :: (T.Protocol p, T.Transport t) => p t -> UpdateTopology_result -> P.IO ()
write_UpdateTopology_result oprot record = T.writeVal oprot $ from_UpdateTopology_result record
encode_UpdateTopology_result :: (T.Protocol p, T.Transport t) => p t -> UpdateTopology_result -> LBS.ByteString
encode_UpdateTopology_result oprot record = T.serializeVal oprot $ from_UpdateTopology_result record
to_UpdateTopology_result :: T.ThriftVal -> UpdateTopology_result
to_UpdateTopology_result (T.TStruct fields) = UpdateTopology_result{
  updateTopology_result_e = P.maybe (P.Nothing) (\(_,_val304) -> P.Just (case _val304 of {T.TStruct _val305 -> (to_BoltError (T.TStruct _val305)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateTopology_result _ = P.error "not a struct"
read_UpdateTopology_result :: (T.Transport t, T.Protocol p) => p t -> P.IO UpdateTopology_result
read_UpdateTopology_result iprot = to_UpdateTopology_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateTopology_result)
decode_UpdateTopology_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> UpdateTopology_result
decode_UpdateTopology_result iprot bs = to_UpdateTopology_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateTopology_result) bs
typemap_UpdateTopology_result :: T.TypeMap
typemap_UpdateTopology_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_BoltError)))]
default_UpdateTopology_result :: UpdateTopology_result
default_UpdateTopology_result = UpdateTopology_result{
  updateTopology_result_e = P.Nothing}
data DispatchRecords_args = DispatchRecords_args  { dispatchRecords_args_records :: (Vector.Vector Record)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable DispatchRecords_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` dispatchRecords_args_records record  
instance QC.Arbitrary DispatchRecords_args where 
  arbitrary = M.liftM DispatchRecords_args (QC.arbitrary)
  shrink obj | obj == default_DispatchRecords_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DispatchRecords_args{dispatchRecords_args_records = dispatchRecords_args_records obj} then P.Nothing else P.Just $ default_DispatchRecords_args{dispatchRecords_args_records = dispatchRecords_args_records obj}
    ]
from_DispatchRecords_args :: DispatchRecords_args -> T.ThriftVal
from_DispatchRecords_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v308 -> P.Just (1, ("records",T.TList (T.T_STRUCT typemap_Record) $ P.map (\_v310 -> from_Record _v310) $ Vector.toList _v308))) $ dispatchRecords_args_records record
  ]
write_DispatchRecords_args :: (T.Protocol p, T.Transport t) => p t -> DispatchRecords_args -> P.IO ()
write_DispatchRecords_args oprot record = T.writeVal oprot $ from_DispatchRecords_args record
encode_DispatchRecords_args :: (T.Protocol p, T.Transport t) => p t -> DispatchRecords_args -> LBS.ByteString
encode_DispatchRecords_args oprot record = T.serializeVal oprot $ from_DispatchRecords_args record
to_DispatchRecords_args :: T.ThriftVal -> DispatchRecords_args
to_DispatchRecords_args (T.TStruct fields) = DispatchRecords_args{
  dispatchRecords_args_records = P.maybe (dispatchRecords_args_records default_DispatchRecords_args) (\(_,_val312) -> (case _val312 of {T.TList _ _val313 -> (Vector.fromList $ P.map (\_v314 -> (case _v314 of {T.TStruct _val315 -> (to_Record (T.TStruct _val315)); _ -> P.error "wrong type"})) _val313); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DispatchRecords_args _ = P.error "not a struct"
read_DispatchRecords_args :: (T.Transport t, T.Protocol p) => p t -> P.IO DispatchRecords_args
read_DispatchRecords_args iprot = to_DispatchRecords_args <$> T.readVal iprot (T.T_STRUCT typemap_DispatchRecords_args)
decode_DispatchRecords_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> DispatchRecords_args
decode_DispatchRecords_args iprot bs = to_DispatchRecords_args $ T.deserializeVal iprot (T.T_STRUCT typemap_DispatchRecords_args) bs
typemap_DispatchRecords_args :: T.TypeMap
typemap_DispatchRecords_args = Map.fromList [(1,("records",(T.T_LIST (T.T_STRUCT typemap_Record))))]
default_DispatchRecords_args :: DispatchRecords_args
default_DispatchRecords_args = DispatchRecords_args{
  dispatchRecords_args_records = Vector.empty}
data DispatchRecords_result = DispatchRecords_result  { dispatchRecords_result_e :: P.Maybe BoltError
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable DispatchRecords_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` dispatchRecords_result_e record  
instance QC.Arbitrary DispatchRecords_result where 
  arbitrary = M.liftM DispatchRecords_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_DispatchRecords_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DispatchRecords_result{dispatchRecords_result_e = dispatchRecords_result_e obj} then P.Nothing else P.Just $ default_DispatchRecords_result{dispatchRecords_result_e = dispatchRecords_result_e obj}
    ]
from_DispatchRecords_result :: DispatchRecords_result -> T.ThriftVal
from_DispatchRecords_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v318 -> (1, ("e",from_BoltError _v318))) <$> dispatchRecords_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v318 -> (1, ("e",from_BoltError _v318))) <$> dispatchRecords_result_e record
    ]
    )
write_DispatchRecords_result :: (T.Protocol p, T.Transport t) => p t -> DispatchRecords_result -> P.IO ()
write_DispatchRecords_result oprot record = T.writeVal oprot $ from_DispatchRecords_result record
encode_DispatchRecords_result :: (T.Protocol p, T.Transport t) => p t -> DispatchRecords_result -> LBS.ByteString
encode_DispatchRecords_result oprot record = T.serializeVal oprot $ from_DispatchRecords_result record
to_DispatchRecords_result :: T.ThriftVal -> DispatchRecords_result
to_DispatchRecords_result (T.TStruct fields) = DispatchRecords_result{
  dispatchRecords_result_e = P.maybe (P.Nothing) (\(_,_val320) -> P.Just (case _val320 of {T.TStruct _val321 -> (to_BoltError (T.TStruct _val321)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DispatchRecords_result _ = P.error "not a struct"
read_DispatchRecords_result :: (T.Transport t, T.Protocol p) => p t -> P.IO DispatchRecords_result
read_DispatchRecords_result iprot = to_DispatchRecords_result <$> T.readVal iprot (T.T_STRUCT typemap_DispatchRecords_result)
decode_DispatchRecords_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> DispatchRecords_result
decode_DispatchRecords_result iprot bs = to_DispatchRecords_result $ T.deserializeVal iprot (T.T_STRUCT typemap_DispatchRecords_result) bs
typemap_DispatchRecords_result :: T.TypeMap
typemap_DispatchRecords_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_BoltError)))]
default_DispatchRecords_result :: DispatchRecords_result
default_DispatchRecords_result = DispatchRecords_result{
  dispatchRecords_result_e = P.Nothing}
data UpdateSchedulerAddress_args = UpdateSchedulerAddress_args  { updateSchedulerAddress_args_e :: Endpoint
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable UpdateSchedulerAddress_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSchedulerAddress_args_e record  
instance QC.Arbitrary UpdateSchedulerAddress_args where 
  arbitrary = M.liftM UpdateSchedulerAddress_args (QC.arbitrary)
  shrink obj | obj == default_UpdateSchedulerAddress_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSchedulerAddress_args{updateSchedulerAddress_args_e = updateSchedulerAddress_args_e obj} then P.Nothing else P.Just $ default_UpdateSchedulerAddress_args{updateSchedulerAddress_args_e = updateSchedulerAddress_args_e obj}
    ]
from_UpdateSchedulerAddress_args :: UpdateSchedulerAddress_args -> T.ThriftVal
from_UpdateSchedulerAddress_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v324 -> P.Just (1, ("e",from_Endpoint _v324))) $ updateSchedulerAddress_args_e record
  ]
write_UpdateSchedulerAddress_args :: (T.Protocol p, T.Transport t) => p t -> UpdateSchedulerAddress_args -> P.IO ()
write_UpdateSchedulerAddress_args oprot record = T.writeVal oprot $ from_UpdateSchedulerAddress_args record
encode_UpdateSchedulerAddress_args :: (T.Protocol p, T.Transport t) => p t -> UpdateSchedulerAddress_args -> LBS.ByteString
encode_UpdateSchedulerAddress_args oprot record = T.serializeVal oprot $ from_UpdateSchedulerAddress_args record
to_UpdateSchedulerAddress_args :: T.ThriftVal -> UpdateSchedulerAddress_args
to_UpdateSchedulerAddress_args (T.TStruct fields) = UpdateSchedulerAddress_args{
  updateSchedulerAddress_args_e = P.maybe (updateSchedulerAddress_args_e default_UpdateSchedulerAddress_args) (\(_,_val326) -> (case _val326 of {T.TStruct _val327 -> (to_Endpoint (T.TStruct _val327)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSchedulerAddress_args _ = P.error "not a struct"
read_UpdateSchedulerAddress_args :: (T.Transport t, T.Protocol p) => p t -> P.IO UpdateSchedulerAddress_args
read_UpdateSchedulerAddress_args iprot = to_UpdateSchedulerAddress_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSchedulerAddress_args)
decode_UpdateSchedulerAddress_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> UpdateSchedulerAddress_args
decode_UpdateSchedulerAddress_args iprot bs = to_UpdateSchedulerAddress_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSchedulerAddress_args) bs
typemap_UpdateSchedulerAddress_args :: T.TypeMap
typemap_UpdateSchedulerAddress_args = Map.fromList [(1,("e",(T.T_STRUCT typemap_Endpoint)))]
default_UpdateSchedulerAddress_args :: UpdateSchedulerAddress_args
default_UpdateSchedulerAddress_args = UpdateSchedulerAddress_args{
  updateSchedulerAddress_args_e = default_Endpoint}
data UpdateSchedulerAddress_result = UpdateSchedulerAddress_result  { updateSchedulerAddress_result_e :: P.Maybe BoltError
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable UpdateSchedulerAddress_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSchedulerAddress_result_e record  
instance QC.Arbitrary UpdateSchedulerAddress_result where 
  arbitrary = M.liftM UpdateSchedulerAddress_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSchedulerAddress_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSchedulerAddress_result{updateSchedulerAddress_result_e = updateSchedulerAddress_result_e obj} then P.Nothing else P.Just $ default_UpdateSchedulerAddress_result{updateSchedulerAddress_result_e = updateSchedulerAddress_result_e obj}
    ]
from_UpdateSchedulerAddress_result :: UpdateSchedulerAddress_result -> T.ThriftVal
from_UpdateSchedulerAddress_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v330 -> (1, ("e",from_BoltError _v330))) <$> updateSchedulerAddress_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v330 -> (1, ("e",from_BoltError _v330))) <$> updateSchedulerAddress_result_e record
    ]
    )
write_UpdateSchedulerAddress_result :: (T.Protocol p, T.Transport t) => p t -> UpdateSchedulerAddress_result -> P.IO ()
write_UpdateSchedulerAddress_result oprot record = T.writeVal oprot $ from_UpdateSchedulerAddress_result record
encode_UpdateSchedulerAddress_result :: (T.Protocol p, T.Transport t) => p t -> UpdateSchedulerAddress_result -> LBS.ByteString
encode_UpdateSchedulerAddress_result oprot record = T.serializeVal oprot $ from_UpdateSchedulerAddress_result record
to_UpdateSchedulerAddress_result :: T.ThriftVal -> UpdateSchedulerAddress_result
to_UpdateSchedulerAddress_result (T.TStruct fields) = UpdateSchedulerAddress_result{
  updateSchedulerAddress_result_e = P.maybe (P.Nothing) (\(_,_val332) -> P.Just (case _val332 of {T.TStruct _val333 -> (to_BoltError (T.TStruct _val333)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSchedulerAddress_result _ = P.error "not a struct"
read_UpdateSchedulerAddress_result :: (T.Transport t, T.Protocol p) => p t -> P.IO UpdateSchedulerAddress_result
read_UpdateSchedulerAddress_result iprot = to_UpdateSchedulerAddress_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSchedulerAddress_result)
decode_UpdateSchedulerAddress_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> UpdateSchedulerAddress_result
decode_UpdateSchedulerAddress_result iprot bs = to_UpdateSchedulerAddress_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSchedulerAddress_result) bs
typemap_UpdateSchedulerAddress_result :: T.TypeMap
typemap_UpdateSchedulerAddress_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_BoltError)))]
default_UpdateSchedulerAddress_result :: UpdateSchedulerAddress_result
default_UpdateSchedulerAddress_result = UpdateSchedulerAddress_result{
  updateSchedulerAddress_result_e = P.Nothing}
data RegisterWithScheduler_args = RegisterWithScheduler_args  { registerWithScheduler_args_meta :: ComputationMetadata
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable RegisterWithScheduler_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithScheduler_args_meta record  
instance QC.Arbitrary RegisterWithScheduler_args where 
  arbitrary = M.liftM RegisterWithScheduler_args (QC.arbitrary)
  shrink obj | obj == default_RegisterWithScheduler_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithScheduler_args{registerWithScheduler_args_meta = registerWithScheduler_args_meta obj} then P.Nothing else P.Just $ default_RegisterWithScheduler_args{registerWithScheduler_args_meta = registerWithScheduler_args_meta obj}
    ]
from_RegisterWithScheduler_args :: RegisterWithScheduler_args -> T.ThriftVal
from_RegisterWithScheduler_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v336 -> P.Just (1, ("meta",from_ComputationMetadata _v336))) $ registerWithScheduler_args_meta record
  ]
write_RegisterWithScheduler_args :: (T.Protocol p, T.Transport t) => p t -> RegisterWithScheduler_args -> P.IO ()
write_RegisterWithScheduler_args oprot record = T.writeVal oprot $ from_RegisterWithScheduler_args record
encode_RegisterWithScheduler_args :: (T.Protocol p, T.Transport t) => p t -> RegisterWithScheduler_args -> LBS.ByteString
encode_RegisterWithScheduler_args oprot record = T.serializeVal oprot $ from_RegisterWithScheduler_args record
to_RegisterWithScheduler_args :: T.ThriftVal -> RegisterWithScheduler_args
to_RegisterWithScheduler_args (T.TStruct fields) = RegisterWithScheduler_args{
  registerWithScheduler_args_meta = P.maybe (registerWithScheduler_args_meta default_RegisterWithScheduler_args) (\(_,_val338) -> (case _val338 of {T.TStruct _val339 -> (to_ComputationMetadata (T.TStruct _val339)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterWithScheduler_args _ = P.error "not a struct"
read_RegisterWithScheduler_args :: (T.Transport t, T.Protocol p) => p t -> P.IO RegisterWithScheduler_args
read_RegisterWithScheduler_args iprot = to_RegisterWithScheduler_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithScheduler_args)
decode_RegisterWithScheduler_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> RegisterWithScheduler_args
decode_RegisterWithScheduler_args iprot bs = to_RegisterWithScheduler_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithScheduler_args) bs
typemap_RegisterWithScheduler_args :: T.TypeMap
typemap_RegisterWithScheduler_args = Map.fromList [(1,("meta",(T.T_STRUCT typemap_ComputationMetadata)))]
default_RegisterWithScheduler_args :: RegisterWithScheduler_args
default_RegisterWithScheduler_args = RegisterWithScheduler_args{
  registerWithScheduler_args_meta = default_ComputationMetadata}
data RegisterWithScheduler_result = RegisterWithScheduler_result deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable RegisterWithScheduler_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary RegisterWithScheduler_result where 
  arbitrary = QC.elements [RegisterWithScheduler_result]
from_RegisterWithScheduler_result :: RegisterWithScheduler_result -> T.ThriftVal
from_RegisterWithScheduler_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_RegisterWithScheduler_result :: (T.Protocol p, T.Transport t) => p t -> RegisterWithScheduler_result -> P.IO ()
write_RegisterWithScheduler_result oprot record = T.writeVal oprot $ from_RegisterWithScheduler_result record
encode_RegisterWithScheduler_result :: (T.Protocol p, T.Transport t) => p t -> RegisterWithScheduler_result -> LBS.ByteString
encode_RegisterWithScheduler_result oprot record = T.serializeVal oprot $ from_RegisterWithScheduler_result record
to_RegisterWithScheduler_result :: T.ThriftVal -> RegisterWithScheduler_result
to_RegisterWithScheduler_result (T.TStruct fields) = RegisterWithScheduler_result{

  }
to_RegisterWithScheduler_result _ = P.error "not a struct"
read_RegisterWithScheduler_result :: (T.Transport t, T.Protocol p) => p t -> P.IO RegisterWithScheduler_result
read_RegisterWithScheduler_result iprot = to_RegisterWithScheduler_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithScheduler_result)
decode_RegisterWithScheduler_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> RegisterWithScheduler_result
decode_RegisterWithScheduler_result iprot bs = to_RegisterWithScheduler_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithScheduler_result) bs
typemap_RegisterWithScheduler_result :: T.TypeMap
typemap_RegisterWithScheduler_result = Map.fromList []
default_RegisterWithScheduler_result :: RegisterWithScheduler_result
default_RegisterWithScheduler_result = RegisterWithScheduler_result{
}
process_updateTopology (seqid, iprot, oprot, handler) = do
  args <- read_UpdateTopology_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateTopology handler (updateTopology_args_topology args)
        let res = default_UpdateTopology_result
        T.writeMessageBegin oprot ("updateTopology", T.M_REPLY, seqid)
        write_UpdateTopology_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_UpdateTopology_result{updateTopology_result_e = P.Just e}
        T.writeMessageBegin oprot ("updateTopology", T.M_REPLY, seqid)
        write_UpdateTopology_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("updateTopology", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_dispatchRecords (seqid, iprot, oprot, handler) = do
  args <- read_DispatchRecords_args iprot
  (X.catch
    (X.catch
      (do
        Iface.dispatchRecords handler (dispatchRecords_args_records args)
        let res = default_DispatchRecords_result
        T.writeMessageBegin oprot ("dispatchRecords", T.M_REPLY, seqid)
        write_DispatchRecords_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_DispatchRecords_result{dispatchRecords_result_e = P.Just e}
        T.writeMessageBegin oprot ("dispatchRecords", T.M_REPLY, seqid)
        write_DispatchRecords_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("dispatchRecords", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_updateSchedulerAddress (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSchedulerAddress_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateSchedulerAddress handler (updateSchedulerAddress_args_e args)
        let res = default_UpdateSchedulerAddress_result
        T.writeMessageBegin oprot ("updateSchedulerAddress", T.M_REPLY, seqid)
        write_UpdateSchedulerAddress_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_UpdateSchedulerAddress_result{updateSchedulerAddress_result_e = P.Just e}
        T.writeMessageBegin oprot ("updateSchedulerAddress", T.M_REPLY, seqid)
        write_UpdateSchedulerAddress_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("updateSchedulerAddress", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_registerWithScheduler (seqid, iprot, oprot, handler) = do
  args <- read_RegisterWithScheduler_args iprot
  (X.catch
    (do
      Iface.registerWithScheduler handler (registerWithScheduler_args_meta args)
      P.return ())
    ((\_ -> do
      P.return ()) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "updateTopology" -> process_updateTopology (seqid,iprot,oprot,handler)
  "dispatchRecords" -> process_dispatchRecords (seqid,iprot,oprot,handler)
  "updateSchedulerAddress" -> process_updateSchedulerAddress (seqid,iprot,oprot,handler)
  "registerWithScheduler" -> process_registerWithScheduler (seqid,iprot,oprot,handler)
  _ -> MutableEphemeralStateService.proc_ handler (iprot,oprot) (name,typ,seqid)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- T.readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  T.readMessageEnd iprot
  P.return P.True
