{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.2)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module BoltSchedulerService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Bolt_Types
import qualified BoltSchedulerService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data DeployComputation_args = DeployComputation_args  { deployComputation_args_request :: BoltComputationRequest
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable DeployComputation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` deployComputation_args_request record  
instance QC.Arbitrary DeployComputation_args where 
  arbitrary = M.liftM DeployComputation_args (QC.arbitrary)
  shrink obj | obj == default_DeployComputation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DeployComputation_args{deployComputation_args_request = deployComputation_args_request obj} then P.Nothing else P.Just $ default_DeployComputation_args{deployComputation_args_request = deployComputation_args_request obj}
    ]
from_DeployComputation_args :: DeployComputation_args -> T.ThriftVal
from_DeployComputation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v347 -> P.Just (1, ("request",from_BoltComputationRequest _v347))) $ deployComputation_args_request record
  ]
write_DeployComputation_args :: (T.Protocol p, T.Transport t) => p t -> DeployComputation_args -> P.IO ()
write_DeployComputation_args oprot record = T.writeVal oprot $ from_DeployComputation_args record
encode_DeployComputation_args :: (T.Protocol p, T.Transport t) => p t -> DeployComputation_args -> LBS.ByteString
encode_DeployComputation_args oprot record = T.serializeVal oprot $ from_DeployComputation_args record
to_DeployComputation_args :: T.ThriftVal -> DeployComputation_args
to_DeployComputation_args (T.TStruct fields) = DeployComputation_args{
  deployComputation_args_request = P.maybe (deployComputation_args_request default_DeployComputation_args) (\(_,_val349) -> (case _val349 of {T.TStruct _val350 -> (to_BoltComputationRequest (T.TStruct _val350)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DeployComputation_args _ = P.error "not a struct"
read_DeployComputation_args :: (T.Transport t, T.Protocol p) => p t -> P.IO DeployComputation_args
read_DeployComputation_args iprot = to_DeployComputation_args <$> T.readVal iprot (T.T_STRUCT typemap_DeployComputation_args)
decode_DeployComputation_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> DeployComputation_args
decode_DeployComputation_args iprot bs = to_DeployComputation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_DeployComputation_args) bs
typemap_DeployComputation_args :: T.TypeMap
typemap_DeployComputation_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_BoltComputationRequest)))]
default_DeployComputation_args :: DeployComputation_args
default_DeployComputation_args = DeployComputation_args{
  deployComputation_args_request = default_BoltComputationRequest}
data DeployComputation_result = DeployComputation_result  { deployComputation_result_e :: P.Maybe BoltError
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable DeployComputation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` deployComputation_result_e record  
instance QC.Arbitrary DeployComputation_result where 
  arbitrary = M.liftM DeployComputation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_DeployComputation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DeployComputation_result{deployComputation_result_e = deployComputation_result_e obj} then P.Nothing else P.Just $ default_DeployComputation_result{deployComputation_result_e = deployComputation_result_e obj}
    ]
from_DeployComputation_result :: DeployComputation_result -> T.ThriftVal
from_DeployComputation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v353 -> (1, ("e",from_BoltError _v353))) <$> deployComputation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v353 -> (1, ("e",from_BoltError _v353))) <$> deployComputation_result_e record
    ]
    )
write_DeployComputation_result :: (T.Protocol p, T.Transport t) => p t -> DeployComputation_result -> P.IO ()
write_DeployComputation_result oprot record = T.writeVal oprot $ from_DeployComputation_result record
encode_DeployComputation_result :: (T.Protocol p, T.Transport t) => p t -> DeployComputation_result -> LBS.ByteString
encode_DeployComputation_result oprot record = T.serializeVal oprot $ from_DeployComputation_result record
to_DeployComputation_result :: T.ThriftVal -> DeployComputation_result
to_DeployComputation_result (T.TStruct fields) = DeployComputation_result{
  deployComputation_result_e = P.maybe (P.Nothing) (\(_,_val355) -> P.Just (case _val355 of {T.TStruct _val356 -> (to_BoltError (T.TStruct _val356)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DeployComputation_result _ = P.error "not a struct"
read_DeployComputation_result :: (T.Transport t, T.Protocol p) => p t -> P.IO DeployComputation_result
read_DeployComputation_result iprot = to_DeployComputation_result <$> T.readVal iprot (T.T_STRUCT typemap_DeployComputation_result)
decode_DeployComputation_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> DeployComputation_result
decode_DeployComputation_result iprot bs = to_DeployComputation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_DeployComputation_result) bs
typemap_DeployComputation_result :: T.TypeMap
typemap_DeployComputation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_BoltError)))]
default_DeployComputation_result :: DeployComputation_result
default_DeployComputation_result = DeployComputation_result{
  deployComputation_result_e = P.Nothing}
data GetComputationSlug_args = GetComputationSlug_args  { getComputationSlug_args_computationName :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetComputationSlug_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getComputationSlug_args_computationName record  
instance QC.Arbitrary GetComputationSlug_args where 
  arbitrary = M.liftM GetComputationSlug_args (QC.arbitrary)
  shrink obj | obj == default_GetComputationSlug_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetComputationSlug_args{getComputationSlug_args_computationName = getComputationSlug_args_computationName obj} then P.Nothing else P.Just $ default_GetComputationSlug_args{getComputationSlug_args_computationName = getComputationSlug_args_computationName obj}
    ]
from_GetComputationSlug_args :: GetComputationSlug_args -> T.ThriftVal
from_GetComputationSlug_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v359 -> P.Just (1, ("computationName",T.TString $ E.encodeUtf8 _v359))) $ getComputationSlug_args_computationName record
  ]
write_GetComputationSlug_args :: (T.Protocol p, T.Transport t) => p t -> GetComputationSlug_args -> P.IO ()
write_GetComputationSlug_args oprot record = T.writeVal oprot $ from_GetComputationSlug_args record
encode_GetComputationSlug_args :: (T.Protocol p, T.Transport t) => p t -> GetComputationSlug_args -> LBS.ByteString
encode_GetComputationSlug_args oprot record = T.serializeVal oprot $ from_GetComputationSlug_args record
to_GetComputationSlug_args :: T.ThriftVal -> GetComputationSlug_args
to_GetComputationSlug_args (T.TStruct fields) = GetComputationSlug_args{
  getComputationSlug_args_computationName = P.maybe (getComputationSlug_args_computationName default_GetComputationSlug_args) (\(_,_val361) -> (case _val361 of {T.TString _val362 -> E.decodeUtf8 _val362; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetComputationSlug_args _ = P.error "not a struct"
read_GetComputationSlug_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetComputationSlug_args
read_GetComputationSlug_args iprot = to_GetComputationSlug_args <$> T.readVal iprot (T.T_STRUCT typemap_GetComputationSlug_args)
decode_GetComputationSlug_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetComputationSlug_args
decode_GetComputationSlug_args iprot bs = to_GetComputationSlug_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetComputationSlug_args) bs
typemap_GetComputationSlug_args :: T.TypeMap
typemap_GetComputationSlug_args = Map.fromList [(1,("computationName",T.T_STRING))]
default_GetComputationSlug_args :: GetComputationSlug_args
default_GetComputationSlug_args = GetComputationSlug_args{
  getComputationSlug_args_computationName = ""}
data GetComputationSlug_result = GetComputationSlug_result  { getComputationSlug_result_success :: LBS.ByteString
  , getComputationSlug_result_e :: P.Maybe BoltError
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable GetComputationSlug_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getComputationSlug_result_success record   `H.hashWithSalt` getComputationSlug_result_e record  
instance QC.Arbitrary GetComputationSlug_result where 
  arbitrary = M.liftM GetComputationSlug_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetComputationSlug_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetComputationSlug_result{getComputationSlug_result_success = getComputationSlug_result_success obj} then P.Nothing else P.Just $ default_GetComputationSlug_result{getComputationSlug_result_success = getComputationSlug_result_success obj}
    , if obj == default_GetComputationSlug_result{getComputationSlug_result_e = getComputationSlug_result_e obj} then P.Nothing else P.Just $ default_GetComputationSlug_result{getComputationSlug_result_e = getComputationSlug_result_e obj}
    ]
from_GetComputationSlug_result :: GetComputationSlug_result -> T.ThriftVal
from_GetComputationSlug_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v365 -> (1, ("e",from_BoltError _v365))) <$> getComputationSlug_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v365 -> P.Just (0, ("success",T.TString _v365))) $ getComputationSlug_result_success record
    , (\_v365 -> (1, ("e",from_BoltError _v365))) <$> getComputationSlug_result_e record
    ]
    )
write_GetComputationSlug_result :: (T.Protocol p, T.Transport t) => p t -> GetComputationSlug_result -> P.IO ()
write_GetComputationSlug_result oprot record = T.writeVal oprot $ from_GetComputationSlug_result record
encode_GetComputationSlug_result :: (T.Protocol p, T.Transport t) => p t -> GetComputationSlug_result -> LBS.ByteString
encode_GetComputationSlug_result oprot record = T.serializeVal oprot $ from_GetComputationSlug_result record
to_GetComputationSlug_result :: T.ThriftVal -> GetComputationSlug_result
to_GetComputationSlug_result (T.TStruct fields) = GetComputationSlug_result{
  getComputationSlug_result_success = P.maybe (getComputationSlug_result_success default_GetComputationSlug_result) (\(_,_val367) -> (case _val367 of {T.TString _val368 -> _val368; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getComputationSlug_result_e = P.maybe (P.Nothing) (\(_,_val367) -> P.Just (case _val367 of {T.TStruct _val369 -> (to_BoltError (T.TStruct _val369)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetComputationSlug_result _ = P.error "not a struct"
read_GetComputationSlug_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetComputationSlug_result
read_GetComputationSlug_result iprot = to_GetComputationSlug_result <$> T.readVal iprot (T.T_STRUCT typemap_GetComputationSlug_result)
decode_GetComputationSlug_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetComputationSlug_result
decode_GetComputationSlug_result iprot bs = to_GetComputationSlug_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetComputationSlug_result) bs
typemap_GetComputationSlug_result :: T.TypeMap
typemap_GetComputationSlug_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_BoltError)))]
default_GetComputationSlug_result :: GetComputationSlug_result
default_GetComputationSlug_result = GetComputationSlug_result{
  getComputationSlug_result_success = "",
  getComputationSlug_result_e = P.Nothing}
data RegisterComputation_args = RegisterComputation_args  { registerComputation_args_computation :: ComputationMetadata
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable RegisterComputation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerComputation_args_computation record  
instance QC.Arbitrary RegisterComputation_args where 
  arbitrary = M.liftM RegisterComputation_args (QC.arbitrary)
  shrink obj | obj == default_RegisterComputation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterComputation_args{registerComputation_args_computation = registerComputation_args_computation obj} then P.Nothing else P.Just $ default_RegisterComputation_args{registerComputation_args_computation = registerComputation_args_computation obj}
    ]
from_RegisterComputation_args :: RegisterComputation_args -> T.ThriftVal
from_RegisterComputation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v372 -> P.Just (1, ("computation",from_ComputationMetadata _v372))) $ registerComputation_args_computation record
  ]
write_RegisterComputation_args :: (T.Protocol p, T.Transport t) => p t -> RegisterComputation_args -> P.IO ()
write_RegisterComputation_args oprot record = T.writeVal oprot $ from_RegisterComputation_args record
encode_RegisterComputation_args :: (T.Protocol p, T.Transport t) => p t -> RegisterComputation_args -> LBS.ByteString
encode_RegisterComputation_args oprot record = T.serializeVal oprot $ from_RegisterComputation_args record
to_RegisterComputation_args :: T.ThriftVal -> RegisterComputation_args
to_RegisterComputation_args (T.TStruct fields) = RegisterComputation_args{
  registerComputation_args_computation = P.maybe (registerComputation_args_computation default_RegisterComputation_args) (\(_,_val374) -> (case _val374 of {T.TStruct _val375 -> (to_ComputationMetadata (T.TStruct _val375)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterComputation_args _ = P.error "not a struct"
read_RegisterComputation_args :: (T.Transport t, T.Protocol p) => p t -> P.IO RegisterComputation_args
read_RegisterComputation_args iprot = to_RegisterComputation_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterComputation_args)
decode_RegisterComputation_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> RegisterComputation_args
decode_RegisterComputation_args iprot bs = to_RegisterComputation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterComputation_args) bs
typemap_RegisterComputation_args :: T.TypeMap
typemap_RegisterComputation_args = Map.fromList [(1,("computation",(T.T_STRUCT typemap_ComputationMetadata)))]
default_RegisterComputation_args :: RegisterComputation_args
default_RegisterComputation_args = RegisterComputation_args{
  registerComputation_args_computation = default_ComputationMetadata}
data RegisterComputation_result = RegisterComputation_result  { registerComputation_result_success :: TopologyMetadata
  , registerComputation_result_e :: P.Maybe BoltError
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable RegisterComputation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerComputation_result_success record   `H.hashWithSalt` registerComputation_result_e record  
instance QC.Arbitrary RegisterComputation_result where 
  arbitrary = M.liftM RegisterComputation_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterComputation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterComputation_result{registerComputation_result_success = registerComputation_result_success obj} then P.Nothing else P.Just $ default_RegisterComputation_result{registerComputation_result_success = registerComputation_result_success obj}
    , if obj == default_RegisterComputation_result{registerComputation_result_e = registerComputation_result_e obj} then P.Nothing else P.Just $ default_RegisterComputation_result{registerComputation_result_e = registerComputation_result_e obj}
    ]
from_RegisterComputation_result :: RegisterComputation_result -> T.ThriftVal
from_RegisterComputation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v378 -> (1, ("e",from_BoltError _v378))) <$> registerComputation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v378 -> P.Just (0, ("success",from_TopologyMetadata _v378))) $ registerComputation_result_success record
    , (\_v378 -> (1, ("e",from_BoltError _v378))) <$> registerComputation_result_e record
    ]
    )
write_RegisterComputation_result :: (T.Protocol p, T.Transport t) => p t -> RegisterComputation_result -> P.IO ()
write_RegisterComputation_result oprot record = T.writeVal oprot $ from_RegisterComputation_result record
encode_RegisterComputation_result :: (T.Protocol p, T.Transport t) => p t -> RegisterComputation_result -> LBS.ByteString
encode_RegisterComputation_result oprot record = T.serializeVal oprot $ from_RegisterComputation_result record
to_RegisterComputation_result :: T.ThriftVal -> RegisterComputation_result
to_RegisterComputation_result (T.TStruct fields) = RegisterComputation_result{
  registerComputation_result_success = P.maybe (registerComputation_result_success default_RegisterComputation_result) (\(_,_val380) -> (case _val380 of {T.TStruct _val381 -> (to_TopologyMetadata (T.TStruct _val381)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerComputation_result_e = P.maybe (P.Nothing) (\(_,_val380) -> P.Just (case _val380 of {T.TStruct _val382 -> (to_BoltError (T.TStruct _val382)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterComputation_result _ = P.error "not a struct"
read_RegisterComputation_result :: (T.Transport t, T.Protocol p) => p t -> P.IO RegisterComputation_result
read_RegisterComputation_result iprot = to_RegisterComputation_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterComputation_result)
decode_RegisterComputation_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> RegisterComputation_result
decode_RegisterComputation_result iprot bs = to_RegisterComputation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterComputation_result) bs
typemap_RegisterComputation_result :: T.TypeMap
typemap_RegisterComputation_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TopologyMetadata))),(1,("e",(T.T_STRUCT typemap_BoltError)))]
default_RegisterComputation_result :: RegisterComputation_result
default_RegisterComputation_result = RegisterComputation_result{
  registerComputation_result_success = default_TopologyMetadata,
  registerComputation_result_e = P.Nothing}
data ScaleComputation_args = ScaleComputation_args  { scaleComputation_args_computationName :: LT.Text
  , scaleComputation_args_instances :: I.Int64
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ScaleComputation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` scaleComputation_args_computationName record   `H.hashWithSalt` scaleComputation_args_instances record  
instance QC.Arbitrary ScaleComputation_args where 
  arbitrary = M.liftM ScaleComputation_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ScaleComputation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ScaleComputation_args{scaleComputation_args_computationName = scaleComputation_args_computationName obj} then P.Nothing else P.Just $ default_ScaleComputation_args{scaleComputation_args_computationName = scaleComputation_args_computationName obj}
    , if obj == default_ScaleComputation_args{scaleComputation_args_instances = scaleComputation_args_instances obj} then P.Nothing else P.Just $ default_ScaleComputation_args{scaleComputation_args_instances = scaleComputation_args_instances obj}
    ]
from_ScaleComputation_args :: ScaleComputation_args -> T.ThriftVal
from_ScaleComputation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v385 -> P.Just (1, ("computationName",T.TString $ E.encodeUtf8 _v385))) $ scaleComputation_args_computationName record
  , (\_v385 -> P.Just (2, ("instances",T.TI64 _v385))) $ scaleComputation_args_instances record
  ]
write_ScaleComputation_args :: (T.Protocol p, T.Transport t) => p t -> ScaleComputation_args -> P.IO ()
write_ScaleComputation_args oprot record = T.writeVal oprot $ from_ScaleComputation_args record
encode_ScaleComputation_args :: (T.Protocol p, T.Transport t) => p t -> ScaleComputation_args -> LBS.ByteString
encode_ScaleComputation_args oprot record = T.serializeVal oprot $ from_ScaleComputation_args record
to_ScaleComputation_args :: T.ThriftVal -> ScaleComputation_args
to_ScaleComputation_args (T.TStruct fields) = ScaleComputation_args{
  scaleComputation_args_computationName = P.maybe (scaleComputation_args_computationName default_ScaleComputation_args) (\(_,_val387) -> (case _val387 of {T.TString _val388 -> E.decodeUtf8 _val388; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  scaleComputation_args_instances = P.maybe (scaleComputation_args_instances default_ScaleComputation_args) (\(_,_val387) -> (case _val387 of {T.TI64 _val389 -> _val389; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ScaleComputation_args _ = P.error "not a struct"
read_ScaleComputation_args :: (T.Transport t, T.Protocol p) => p t -> P.IO ScaleComputation_args
read_ScaleComputation_args iprot = to_ScaleComputation_args <$> T.readVal iprot (T.T_STRUCT typemap_ScaleComputation_args)
decode_ScaleComputation_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ScaleComputation_args
decode_ScaleComputation_args iprot bs = to_ScaleComputation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ScaleComputation_args) bs
typemap_ScaleComputation_args :: T.TypeMap
typemap_ScaleComputation_args = Map.fromList [(1,("computationName",T.T_STRING)),(2,("instances",T.T_I64))]
default_ScaleComputation_args :: ScaleComputation_args
default_ScaleComputation_args = ScaleComputation_args{
  scaleComputation_args_computationName = "",
  scaleComputation_args_instances = 0}
data ScaleComputation_result = ScaleComputation_result  { scaleComputation_result_e :: P.Maybe BoltError
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ScaleComputation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` scaleComputation_result_e record  
instance QC.Arbitrary ScaleComputation_result where 
  arbitrary = M.liftM ScaleComputation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ScaleComputation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ScaleComputation_result{scaleComputation_result_e = scaleComputation_result_e obj} then P.Nothing else P.Just $ default_ScaleComputation_result{scaleComputation_result_e = scaleComputation_result_e obj}
    ]
from_ScaleComputation_result :: ScaleComputation_result -> T.ThriftVal
from_ScaleComputation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v392 -> (1, ("e",from_BoltError _v392))) <$> scaleComputation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v392 -> (1, ("e",from_BoltError _v392))) <$> scaleComputation_result_e record
    ]
    )
write_ScaleComputation_result :: (T.Protocol p, T.Transport t) => p t -> ScaleComputation_result -> P.IO ()
write_ScaleComputation_result oprot record = T.writeVal oprot $ from_ScaleComputation_result record
encode_ScaleComputation_result :: (T.Protocol p, T.Transport t) => p t -> ScaleComputation_result -> LBS.ByteString
encode_ScaleComputation_result oprot record = T.serializeVal oprot $ from_ScaleComputation_result record
to_ScaleComputation_result :: T.ThriftVal -> ScaleComputation_result
to_ScaleComputation_result (T.TStruct fields) = ScaleComputation_result{
  scaleComputation_result_e = P.maybe (P.Nothing) (\(_,_val394) -> P.Just (case _val394 of {T.TStruct _val395 -> (to_BoltError (T.TStruct _val395)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ScaleComputation_result _ = P.error "not a struct"
read_ScaleComputation_result :: (T.Transport t, T.Protocol p) => p t -> P.IO ScaleComputation_result
read_ScaleComputation_result iprot = to_ScaleComputation_result <$> T.readVal iprot (T.T_STRUCT typemap_ScaleComputation_result)
decode_ScaleComputation_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ScaleComputation_result
decode_ScaleComputation_result iprot bs = to_ScaleComputation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ScaleComputation_result) bs
typemap_ScaleComputation_result :: T.TypeMap
typemap_ScaleComputation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_BoltError)))]
default_ScaleComputation_result :: ScaleComputation_result
default_ScaleComputation_result = ScaleComputation_result{
  scaleComputation_result_e = P.Nothing}
data KillTask_args = KillTask_args  { killTask_args_taskId :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable KillTask_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` killTask_args_taskId record  
instance QC.Arbitrary KillTask_args where 
  arbitrary = M.liftM KillTask_args (QC.arbitrary)
  shrink obj | obj == default_KillTask_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_KillTask_args{killTask_args_taskId = killTask_args_taskId obj} then P.Nothing else P.Just $ default_KillTask_args{killTask_args_taskId = killTask_args_taskId obj}
    ]
from_KillTask_args :: KillTask_args -> T.ThriftVal
from_KillTask_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v398 -> P.Just (1, ("taskId",T.TString $ E.encodeUtf8 _v398))) $ killTask_args_taskId record
  ]
write_KillTask_args :: (T.Protocol p, T.Transport t) => p t -> KillTask_args -> P.IO ()
write_KillTask_args oprot record = T.writeVal oprot $ from_KillTask_args record
encode_KillTask_args :: (T.Protocol p, T.Transport t) => p t -> KillTask_args -> LBS.ByteString
encode_KillTask_args oprot record = T.serializeVal oprot $ from_KillTask_args record
to_KillTask_args :: T.ThriftVal -> KillTask_args
to_KillTask_args (T.TStruct fields) = KillTask_args{
  killTask_args_taskId = P.maybe (killTask_args_taskId default_KillTask_args) (\(_,_val400) -> (case _val400 of {T.TString _val401 -> E.decodeUtf8 _val401; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_KillTask_args _ = P.error "not a struct"
read_KillTask_args :: (T.Transport t, T.Protocol p) => p t -> P.IO KillTask_args
read_KillTask_args iprot = to_KillTask_args <$> T.readVal iprot (T.T_STRUCT typemap_KillTask_args)
decode_KillTask_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> KillTask_args
decode_KillTask_args iprot bs = to_KillTask_args $ T.deserializeVal iprot (T.T_STRUCT typemap_KillTask_args) bs
typemap_KillTask_args :: T.TypeMap
typemap_KillTask_args = Map.fromList [(1,("taskId",T.T_STRING))]
default_KillTask_args :: KillTask_args
default_KillTask_args = KillTask_args{
  killTask_args_taskId = ""}
data KillTask_result = KillTask_result  { killTask_result_e :: P.Maybe BoltError
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable KillTask_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` killTask_result_e record  
instance QC.Arbitrary KillTask_result where 
  arbitrary = M.liftM KillTask_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_KillTask_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_KillTask_result{killTask_result_e = killTask_result_e obj} then P.Nothing else P.Just $ default_KillTask_result{killTask_result_e = killTask_result_e obj}
    ]
from_KillTask_result :: KillTask_result -> T.ThriftVal
from_KillTask_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v404 -> (1, ("e",from_BoltError _v404))) <$> killTask_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v404 -> (1, ("e",from_BoltError _v404))) <$> killTask_result_e record
    ]
    )
write_KillTask_result :: (T.Protocol p, T.Transport t) => p t -> KillTask_result -> P.IO ()
write_KillTask_result oprot record = T.writeVal oprot $ from_KillTask_result record
encode_KillTask_result :: (T.Protocol p, T.Transport t) => p t -> KillTask_result -> LBS.ByteString
encode_KillTask_result oprot record = T.serializeVal oprot $ from_KillTask_result record
to_KillTask_result :: T.ThriftVal -> KillTask_result
to_KillTask_result (T.TStruct fields) = KillTask_result{
  killTask_result_e = P.maybe (P.Nothing) (\(_,_val406) -> P.Just (case _val406 of {T.TStruct _val407 -> (to_BoltError (T.TStruct _val407)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_KillTask_result _ = P.error "not a struct"
read_KillTask_result :: (T.Transport t, T.Protocol p) => p t -> P.IO KillTask_result
read_KillTask_result iprot = to_KillTask_result <$> T.readVal iprot (T.T_STRUCT typemap_KillTask_result)
decode_KillTask_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> KillTask_result
decode_KillTask_result iprot bs = to_KillTask_result $ T.deserializeVal iprot (T.T_STRUCT typemap_KillTask_result) bs
typemap_KillTask_result :: T.TypeMap
typemap_KillTask_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_BoltError)))]
default_KillTask_result :: KillTask_result
default_KillTask_result = KillTask_result{
  killTask_result_e = P.Nothing}
process_deployComputation (seqid, iprot, oprot, handler) = do
  args <- read_DeployComputation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.deployComputation handler (deployComputation_args_request args)
        let res = default_DeployComputation_result
        T.writeMessageBegin oprot ("deployComputation", T.M_REPLY, seqid)
        write_DeployComputation_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_DeployComputation_result{deployComputation_result_e = P.Just e}
        T.writeMessageBegin oprot ("deployComputation", T.M_REPLY, seqid)
        write_DeployComputation_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("deployComputation", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getComputationSlug (seqid, iprot, oprot, handler) = do
  args <- read_GetComputationSlug_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getComputationSlug handler (getComputationSlug_args_computationName args)
        let res = default_GetComputationSlug_result{getComputationSlug_result_success = val}
        T.writeMessageBegin oprot ("getComputationSlug", T.M_REPLY, seqid)
        write_GetComputationSlug_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_GetComputationSlug_result{getComputationSlug_result_e = P.Just e}
        T.writeMessageBegin oprot ("getComputationSlug", T.M_REPLY, seqid)
        write_GetComputationSlug_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("getComputationSlug", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_registerComputation (seqid, iprot, oprot, handler) = do
  args <- read_RegisterComputation_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerComputation handler (registerComputation_args_computation args)
        let res = default_RegisterComputation_result{registerComputation_result_success = val}
        T.writeMessageBegin oprot ("registerComputation", T.M_REPLY, seqid)
        write_RegisterComputation_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_RegisterComputation_result{registerComputation_result_e = P.Just e}
        T.writeMessageBegin oprot ("registerComputation", T.M_REPLY, seqid)
        write_RegisterComputation_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("registerComputation", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_scaleComputation (seqid, iprot, oprot, handler) = do
  args <- read_ScaleComputation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.scaleComputation handler (scaleComputation_args_computationName args) (scaleComputation_args_instances args)
        let res = default_ScaleComputation_result
        T.writeMessageBegin oprot ("scaleComputation", T.M_REPLY, seqid)
        write_ScaleComputation_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_ScaleComputation_result{scaleComputation_result_e = P.Just e}
        T.writeMessageBegin oprot ("scaleComputation", T.M_REPLY, seqid)
        write_ScaleComputation_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("scaleComputation", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_killTask (seqid, iprot, oprot, handler) = do
  args <- read_KillTask_args iprot
  (X.catch
    (X.catch
      (do
        Iface.killTask handler (killTask_args_taskId args)
        let res = default_KillTask_result
        T.writeMessageBegin oprot ("killTask", T.M_REPLY, seqid)
        write_KillTask_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_KillTask_result{killTask_result_e = P.Just e}
        T.writeMessageBegin oprot ("killTask", T.M_REPLY, seqid)
        write_KillTask_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("killTask", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "deployComputation" -> process_deployComputation (seqid,iprot,oprot,handler)
  "getComputationSlug" -> process_getComputationSlug (seqid,iprot,oprot,handler)
  "registerComputation" -> process_registerComputation (seqid,iprot,oprot,handler)
  "scaleComputation" -> process_scaleComputation (seqid,iprot,oprot,handler)
  "killTask" -> process_killTask (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessageBegin oprot (name,T.M_EXCEPTION,seqid)
    T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
    T.writeMessageEnd oprot
    T.tFlush (T.getTransport oprot)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- T.readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  T.readMessageEnd iprot
  P.return P.True
