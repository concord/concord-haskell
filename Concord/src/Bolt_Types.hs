{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.2)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Bolt_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


data BackPressure = NONE|ENQUEUE|DROP_HEAD|DROP_TAIL|BLOCK_SENDER  deriving (P.Show,P.Eq, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum BackPressure where
  fromEnum t = case t of
    NONE -> 0
    ENQUEUE -> 1
    DROP_HEAD -> 2
    DROP_TAIL -> 3
    BLOCK_SENDER -> 4
  toEnum t = case t of
    0 -> NONE
    1 -> ENQUEUE
    2 -> DROP_HEAD
    3 -> DROP_TAIL
    4 -> BLOCK_SENDER
    _ -> X.throw T.ThriftException
instance H.Hashable BackPressure where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary BackPressure where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data StreamGrouping = ROUND_ROBIN|SHUFFLE|GROUP_BY|LOCAL|CUSTOM  deriving (P.Show,P.Eq, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum StreamGrouping where
  fromEnum t = case t of
    ROUND_ROBIN -> 0
    SHUFFLE -> 1
    GROUP_BY -> 2
    LOCAL -> 3
    CUSTOM -> 100
  toEnum t = case t of
    0 -> ROUND_ROBIN
    1 -> SHUFFLE
    2 -> GROUP_BY
    3 -> LOCAL
    100 -> CUSTOM
    _ -> X.throw T.ThriftException
instance H.Hashable StreamGrouping where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary StreamGrouping where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data Signal = START|ACTIVE|INACTIVE|SHUTDOWN|KILL  deriving (P.Show,P.Eq, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum Signal where
  fromEnum t = case t of
    START -> 0
    ACTIVE -> 1
    INACTIVE -> 2
    SHUTDOWN -> 3
    KILL -> 4
  toEnum t = case t of
    0 -> START
    1 -> ACTIVE
    2 -> INACTIVE
    3 -> SHUTDOWN
    4 -> KILL
    _ -> X.throw T.ThriftException
instance H.Hashable Signal where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary Signal where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data RecordFlags = CLIENT_RECORD|FRAMEWORK_RECORD  deriving (P.Show,P.Eq, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum RecordFlags where
  fromEnum t = case t of
    CLIENT_RECORD -> 1
    FRAMEWORK_RECORD -> 2
  toEnum t = case t of
    1 -> CLIENT_RECORD
    2 -> FRAMEWORK_RECORD
    _ -> X.throw T.ThriftException
instance H.Hashable RecordFlags where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary RecordFlags where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data BoltError = BoltError  { boltError_reason :: LT.Text
  , boltError_context :: LT.Text
  , boltError_time :: I.Int64
  } deriving (P.Show,P.Eq,TY.Typeable)
instance X.Exception BoltError
instance H.Hashable BoltError where
  hashWithSalt salt record = salt   `H.hashWithSalt` boltError_reason record   `H.hashWithSalt` boltError_context record   `H.hashWithSalt` boltError_time record  
instance QC.Arbitrary BoltError where 
  arbitrary = M.liftM BoltError (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BoltError = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BoltError{boltError_reason = boltError_reason obj} then P.Nothing else P.Just $ default_BoltError{boltError_reason = boltError_reason obj}
    , if obj == default_BoltError{boltError_context = boltError_context obj} then P.Nothing else P.Just $ default_BoltError{boltError_context = boltError_context obj}
    , if obj == default_BoltError{boltError_time = boltError_time obj} then P.Nothing else P.Just $ default_BoltError{boltError_time = boltError_time obj}
    ]
from_BoltError :: BoltError -> T.ThriftVal
from_BoltError record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("reason",T.TString $ E.encodeUtf8 _v2))) $ boltError_reason record
  , (\_v2 -> P.Just (2, ("context",T.TString $ E.encodeUtf8 _v2))) $ boltError_context record
  , (\_v2 -> P.Just (3, ("time",T.TI64 _v2))) $ boltError_time record
  ]
write_BoltError :: (T.Protocol p, T.Transport t) => p t -> BoltError -> P.IO ()
write_BoltError oprot record = T.writeVal oprot $ from_BoltError record
encode_BoltError :: (T.Protocol p, T.Transport t) => p t -> BoltError -> LBS.ByteString
encode_BoltError oprot record = T.serializeVal oprot $ from_BoltError record
to_BoltError :: T.ThriftVal -> BoltError
to_BoltError (T.TStruct fields) = BoltError{
  boltError_reason = P.maybe (boltError_reason default_BoltError) (\(_,_val4) -> (case _val4 of {T.TString _val5 -> E.decodeUtf8 _val5; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  boltError_context = P.maybe (boltError_context default_BoltError) (\(_,_val4) -> (case _val4 of {T.TString _val6 -> E.decodeUtf8 _val6; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  boltError_time = P.maybe (boltError_time default_BoltError) (\(_,_val4) -> (case _val4 of {T.TI64 _val7 -> _val7; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_BoltError _ = P.error "not a struct"
read_BoltError :: (T.Transport t, T.Protocol p) => p t -> P.IO BoltError
read_BoltError iprot = to_BoltError <$> T.readVal iprot (T.T_STRUCT typemap_BoltError)
decode_BoltError :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> BoltError
decode_BoltError iprot bs = to_BoltError $ T.deserializeVal iprot (T.T_STRUCT typemap_BoltError) bs
typemap_BoltError :: T.TypeMap
typemap_BoltError = Map.fromList [(1,("reason",T.T_STRING)),(2,("context",T.T_STRING)),(3,("time",T.T_I64))]
default_BoltError :: BoltError
default_BoltError = BoltError{
  boltError_reason = "",
  boltError_context = "",
  boltError_time = 0}
data Endpoint = Endpoint  { endpoint_ip :: LT.Text
  , endpoint_port :: I.Int32
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Endpoint where
  hashWithSalt salt record = salt   `H.hashWithSalt` endpoint_ip record   `H.hashWithSalt` endpoint_port record  
instance QC.Arbitrary Endpoint where 
  arbitrary = M.liftM Endpoint (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Endpoint = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Endpoint{endpoint_ip = endpoint_ip obj} then P.Nothing else P.Just $ default_Endpoint{endpoint_ip = endpoint_ip obj}
    , if obj == default_Endpoint{endpoint_port = endpoint_port obj} then P.Nothing else P.Just $ default_Endpoint{endpoint_port = endpoint_port obj}
    ]
from_Endpoint :: Endpoint -> T.ThriftVal
from_Endpoint record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10 -> P.Just (1, ("ip",T.TString $ E.encodeUtf8 _v10))) $ endpoint_ip record
  , (\_v10 -> P.Just (2, ("port",T.TI32 _v10))) $ endpoint_port record
  ]
write_Endpoint :: (T.Protocol p, T.Transport t) => p t -> Endpoint -> P.IO ()
write_Endpoint oprot record = T.writeVal oprot $ from_Endpoint record
encode_Endpoint :: (T.Protocol p, T.Transport t) => p t -> Endpoint -> LBS.ByteString
encode_Endpoint oprot record = T.serializeVal oprot $ from_Endpoint record
to_Endpoint :: T.ThriftVal -> Endpoint
to_Endpoint (T.TStruct fields) = Endpoint{
  endpoint_ip = P.maybe (endpoint_ip default_Endpoint) (\(_,_val12) -> (case _val12 of {T.TString _val13 -> E.decodeUtf8 _val13; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  endpoint_port = P.maybe (endpoint_port default_Endpoint) (\(_,_val12) -> (case _val12 of {T.TI32 _val14 -> _val14; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Endpoint _ = P.error "not a struct"
read_Endpoint :: (T.Transport t, T.Protocol p) => p t -> P.IO Endpoint
read_Endpoint iprot = to_Endpoint <$> T.readVal iprot (T.T_STRUCT typemap_Endpoint)
decode_Endpoint :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Endpoint
decode_Endpoint iprot bs = to_Endpoint $ T.deserializeVal iprot (T.T_STRUCT typemap_Endpoint) bs
typemap_Endpoint :: T.TypeMap
typemap_Endpoint = Map.fromList [(1,("ip",T.T_STRING)),(2,("port",T.T_I32))]
default_Endpoint :: Endpoint
default_Endpoint = Endpoint{
  endpoint_ip = "",
  endpoint_port = 0}
data StreamMetadata = StreamMetadata  { streamMetadata_name :: LT.Text
  , streamMetadata_grouping :: StreamGrouping
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable StreamMetadata where
  hashWithSalt salt record = salt   `H.hashWithSalt` streamMetadata_name record   `H.hashWithSalt` streamMetadata_grouping record  
instance QC.Arbitrary StreamMetadata where 
  arbitrary = M.liftM StreamMetadata (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_StreamMetadata = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StreamMetadata{streamMetadata_name = streamMetadata_name obj} then P.Nothing else P.Just $ default_StreamMetadata{streamMetadata_name = streamMetadata_name obj}
    , if obj == default_StreamMetadata{streamMetadata_grouping = streamMetadata_grouping obj} then P.Nothing else P.Just $ default_StreamMetadata{streamMetadata_grouping = streamMetadata_grouping obj}
    ]
from_StreamMetadata :: StreamMetadata -> T.ThriftVal
from_StreamMetadata record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v17 -> P.Just (1, ("name",T.TString $ E.encodeUtf8 _v17))) $ streamMetadata_name record
  , (\_v17 -> P.Just (2, ("grouping",T.TI32 $ P.fromIntegral $ P.fromEnum _v17))) $ streamMetadata_grouping record
  ]
write_StreamMetadata :: (T.Protocol p, T.Transport t) => p t -> StreamMetadata -> P.IO ()
write_StreamMetadata oprot record = T.writeVal oprot $ from_StreamMetadata record
encode_StreamMetadata :: (T.Protocol p, T.Transport t) => p t -> StreamMetadata -> LBS.ByteString
encode_StreamMetadata oprot record = T.serializeVal oprot $ from_StreamMetadata record
to_StreamMetadata :: T.ThriftVal -> StreamMetadata
to_StreamMetadata (T.TStruct fields) = StreamMetadata{
  streamMetadata_name = P.maybe (streamMetadata_name default_StreamMetadata) (\(_,_val19) -> (case _val19 of {T.TString _val20 -> E.decodeUtf8 _val20; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  streamMetadata_grouping = P.maybe (streamMetadata_grouping default_StreamMetadata) (\(_,_val19) -> (case _val19 of {T.TI32 _val21 -> P.toEnum $ P.fromIntegral _val21; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_StreamMetadata _ = P.error "not a struct"
read_StreamMetadata :: (T.Transport t, T.Protocol p) => p t -> P.IO StreamMetadata
read_StreamMetadata iprot = to_StreamMetadata <$> T.readVal iprot (T.T_STRUCT typemap_StreamMetadata)
decode_StreamMetadata :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> StreamMetadata
decode_StreamMetadata iprot bs = to_StreamMetadata $ T.deserializeVal iprot (T.T_STRUCT typemap_StreamMetadata) bs
typemap_StreamMetadata :: T.TypeMap
typemap_StreamMetadata = Map.fromList [(1,("name",T.T_STRING)),(2,("grouping",T.T_I32))]
default_StreamMetadata :: StreamMetadata
default_StreamMetadata = StreamMetadata{
  streamMetadata_name = "",
  streamMetadata_grouping = SHUFFLE}
data ComputationMetadata = ComputationMetadata  { computationMetadata_name :: LT.Text
  , computationMetadata_taskId :: LT.Text
  , computationMetadata_istreams :: (Vector.Vector StreamMetadata)
  , computationMetadata_ostreams :: (Vector.Vector LT.Text)
  , computationMetadata_proxyEndpoint :: Endpoint
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ComputationMetadata where
  hashWithSalt salt record = salt   `H.hashWithSalt` computationMetadata_name record   `H.hashWithSalt` computationMetadata_taskId record   `H.hashWithSalt` computationMetadata_istreams record   `H.hashWithSalt` computationMetadata_ostreams record   `H.hashWithSalt` computationMetadata_proxyEndpoint record  
instance QC.Arbitrary ComputationMetadata where 
  arbitrary = M.liftM ComputationMetadata (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ComputationMetadata = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ComputationMetadata{computationMetadata_name = computationMetadata_name obj} then P.Nothing else P.Just $ default_ComputationMetadata{computationMetadata_name = computationMetadata_name obj}
    , if obj == default_ComputationMetadata{computationMetadata_taskId = computationMetadata_taskId obj} then P.Nothing else P.Just $ default_ComputationMetadata{computationMetadata_taskId = computationMetadata_taskId obj}
    , if obj == default_ComputationMetadata{computationMetadata_istreams = computationMetadata_istreams obj} then P.Nothing else P.Just $ default_ComputationMetadata{computationMetadata_istreams = computationMetadata_istreams obj}
    , if obj == default_ComputationMetadata{computationMetadata_ostreams = computationMetadata_ostreams obj} then P.Nothing else P.Just $ default_ComputationMetadata{computationMetadata_ostreams = computationMetadata_ostreams obj}
    , if obj == default_ComputationMetadata{computationMetadata_proxyEndpoint = computationMetadata_proxyEndpoint obj} then P.Nothing else P.Just $ default_ComputationMetadata{computationMetadata_proxyEndpoint = computationMetadata_proxyEndpoint obj}
    ]
from_ComputationMetadata :: ComputationMetadata -> T.ThriftVal
from_ComputationMetadata record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v24 -> P.Just (1, ("name",T.TString $ E.encodeUtf8 _v24))) $ computationMetadata_name record
  , (\_v24 -> P.Just (2, ("taskId",T.TString $ E.encodeUtf8 _v24))) $ computationMetadata_taskId record
  , (\_v24 -> P.Just (3, ("istreams",T.TList (T.T_STRUCT typemap_StreamMetadata) $ P.map (\_v26 -> from_StreamMetadata _v26) $ Vector.toList _v24))) $ computationMetadata_istreams record
  , (\_v24 -> P.Just (4, ("ostreams",T.TList T.T_STRING $ P.map (\_v28 -> T.TString $ E.encodeUtf8 _v28) $ Vector.toList _v24))) $ computationMetadata_ostreams record
  , (\_v24 -> P.Just (5, ("proxyEndpoint",from_Endpoint _v24))) $ computationMetadata_proxyEndpoint record
  ]
write_ComputationMetadata :: (T.Protocol p, T.Transport t) => p t -> ComputationMetadata -> P.IO ()
write_ComputationMetadata oprot record = T.writeVal oprot $ from_ComputationMetadata record
encode_ComputationMetadata :: (T.Protocol p, T.Transport t) => p t -> ComputationMetadata -> LBS.ByteString
encode_ComputationMetadata oprot record = T.serializeVal oprot $ from_ComputationMetadata record
to_ComputationMetadata :: T.ThriftVal -> ComputationMetadata
to_ComputationMetadata (T.TStruct fields) = ComputationMetadata{
  computationMetadata_name = P.maybe (computationMetadata_name default_ComputationMetadata) (\(_,_val30) -> (case _val30 of {T.TString _val31 -> E.decodeUtf8 _val31; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  computationMetadata_taskId = P.maybe (computationMetadata_taskId default_ComputationMetadata) (\(_,_val30) -> (case _val30 of {T.TString _val32 -> E.decodeUtf8 _val32; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  computationMetadata_istreams = P.maybe (computationMetadata_istreams default_ComputationMetadata) (\(_,_val30) -> (case _val30 of {T.TList _ _val33 -> (Vector.fromList $ P.map (\_v34 -> (case _v34 of {T.TStruct _val35 -> (to_StreamMetadata (T.TStruct _val35)); _ -> P.error "wrong type"})) _val33); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  computationMetadata_ostreams = P.maybe (computationMetadata_ostreams default_ComputationMetadata) (\(_,_val30) -> (case _val30 of {T.TList _ _val36 -> (Vector.fromList $ P.map (\_v37 -> (case _v37 of {T.TString _val38 -> E.decodeUtf8 _val38; _ -> P.error "wrong type"})) _val36); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  computationMetadata_proxyEndpoint = P.maybe (computationMetadata_proxyEndpoint default_ComputationMetadata) (\(_,_val30) -> (case _val30 of {T.TStruct _val39 -> (to_Endpoint (T.TStruct _val39)); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_ComputationMetadata _ = P.error "not a struct"
read_ComputationMetadata :: (T.Transport t, T.Protocol p) => p t -> P.IO ComputationMetadata
read_ComputationMetadata iprot = to_ComputationMetadata <$> T.readVal iprot (T.T_STRUCT typemap_ComputationMetadata)
decode_ComputationMetadata :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ComputationMetadata
decode_ComputationMetadata iprot bs = to_ComputationMetadata $ T.deserializeVal iprot (T.T_STRUCT typemap_ComputationMetadata) bs
typemap_ComputationMetadata :: T.TypeMap
typemap_ComputationMetadata = Map.fromList [(1,("name",T.T_STRING)),(2,("taskId",T.T_STRING)),(3,("istreams",(T.T_LIST (T.T_STRUCT typemap_StreamMetadata)))),(4,("ostreams",(T.T_LIST T.T_STRING))),(5,("proxyEndpoint",(T.T_STRUCT typemap_Endpoint)))]
default_ComputationMetadata :: ComputationMetadata
default_ComputationMetadata = ComputationMetadata{
  computationMetadata_name = "",
  computationMetadata_taskId = "",
  computationMetadata_istreams = Vector.empty,
  computationMetadata_ostreams = Vector.empty,
  computationMetadata_proxyEndpoint = default_Endpoint}
data ExecutorTaskInfoHelper = ExecutorTaskInfoHelper  { executorTaskInfoHelper_frameworkLoggingLevel :: I.Int32
  , executorTaskInfoHelper_user :: LT.Text
  , executorTaskInfoHelper_frameworkVModule :: LT.Text
  , executorTaskInfoHelper_scheduler :: Endpoint
  , executorTaskInfoHelper_proxy :: Endpoint
  , executorTaskInfoHelper_client :: Endpoint
  , executorTaskInfoHelper_traceAggregator :: Endpoint
  , executorTaskInfoHelper_execName :: LT.Text
  , executorTaskInfoHelper_folder :: LT.Text
  , executorTaskInfoHelper_computationAliasName :: LT.Text
  , executorTaskInfoHelper_clientArguments :: (Vector.Vector LT.Text)
  , executorTaskInfoHelper_environmentExtra :: (Vector.Vector LT.Text)
  , executorTaskInfoHelper_dockerContainer :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ExecutorTaskInfoHelper where
  hashWithSalt salt record = salt   `H.hashWithSalt` executorTaskInfoHelper_frameworkLoggingLevel record   `H.hashWithSalt` executorTaskInfoHelper_user record   `H.hashWithSalt` executorTaskInfoHelper_frameworkVModule record   `H.hashWithSalt` executorTaskInfoHelper_scheduler record   `H.hashWithSalt` executorTaskInfoHelper_proxy record   `H.hashWithSalt` executorTaskInfoHelper_client record   `H.hashWithSalt` executorTaskInfoHelper_traceAggregator record   `H.hashWithSalt` executorTaskInfoHelper_execName record   `H.hashWithSalt` executorTaskInfoHelper_folder record   `H.hashWithSalt` executorTaskInfoHelper_computationAliasName record   `H.hashWithSalt` executorTaskInfoHelper_clientArguments record   `H.hashWithSalt` executorTaskInfoHelper_environmentExtra record   `H.hashWithSalt` executorTaskInfoHelper_dockerContainer record  
instance QC.Arbitrary ExecutorTaskInfoHelper where 
  arbitrary = M.liftM ExecutorTaskInfoHelper (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ExecutorTaskInfoHelper = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ExecutorTaskInfoHelper{executorTaskInfoHelper_frameworkLoggingLevel = executorTaskInfoHelper_frameworkLoggingLevel obj} then P.Nothing else P.Just $ default_ExecutorTaskInfoHelper{executorTaskInfoHelper_frameworkLoggingLevel = executorTaskInfoHelper_frameworkLoggingLevel obj}
    , if obj == default_ExecutorTaskInfoHelper{executorTaskInfoHelper_user = executorTaskInfoHelper_user obj} then P.Nothing else P.Just $ default_ExecutorTaskInfoHelper{executorTaskInfoHelper_user = executorTaskInfoHelper_user obj}
    , if obj == default_ExecutorTaskInfoHelper{executorTaskInfoHelper_frameworkVModule = executorTaskInfoHelper_frameworkVModule obj} then P.Nothing else P.Just $ default_ExecutorTaskInfoHelper{executorTaskInfoHelper_frameworkVModule = executorTaskInfoHelper_frameworkVModule obj}
    , if obj == default_ExecutorTaskInfoHelper{executorTaskInfoHelper_scheduler = executorTaskInfoHelper_scheduler obj} then P.Nothing else P.Just $ default_ExecutorTaskInfoHelper{executorTaskInfoHelper_scheduler = executorTaskInfoHelper_scheduler obj}
    , if obj == default_ExecutorTaskInfoHelper{executorTaskInfoHelper_proxy = executorTaskInfoHelper_proxy obj} then P.Nothing else P.Just $ default_ExecutorTaskInfoHelper{executorTaskInfoHelper_proxy = executorTaskInfoHelper_proxy obj}
    , if obj == default_ExecutorTaskInfoHelper{executorTaskInfoHelper_client = executorTaskInfoHelper_client obj} then P.Nothing else P.Just $ default_ExecutorTaskInfoHelper{executorTaskInfoHelper_client = executorTaskInfoHelper_client obj}
    , if obj == default_ExecutorTaskInfoHelper{executorTaskInfoHelper_traceAggregator = executorTaskInfoHelper_traceAggregator obj} then P.Nothing else P.Just $ default_ExecutorTaskInfoHelper{executorTaskInfoHelper_traceAggregator = executorTaskInfoHelper_traceAggregator obj}
    , if obj == default_ExecutorTaskInfoHelper{executorTaskInfoHelper_execName = executorTaskInfoHelper_execName obj} then P.Nothing else P.Just $ default_ExecutorTaskInfoHelper{executorTaskInfoHelper_execName = executorTaskInfoHelper_execName obj}
    , if obj == default_ExecutorTaskInfoHelper{executorTaskInfoHelper_folder = executorTaskInfoHelper_folder obj} then P.Nothing else P.Just $ default_ExecutorTaskInfoHelper{executorTaskInfoHelper_folder = executorTaskInfoHelper_folder obj}
    , if obj == default_ExecutorTaskInfoHelper{executorTaskInfoHelper_computationAliasName = executorTaskInfoHelper_computationAliasName obj} then P.Nothing else P.Just $ default_ExecutorTaskInfoHelper{executorTaskInfoHelper_computationAliasName = executorTaskInfoHelper_computationAliasName obj}
    , if obj == default_ExecutorTaskInfoHelper{executorTaskInfoHelper_clientArguments = executorTaskInfoHelper_clientArguments obj} then P.Nothing else P.Just $ default_ExecutorTaskInfoHelper{executorTaskInfoHelper_clientArguments = executorTaskInfoHelper_clientArguments obj}
    , if obj == default_ExecutorTaskInfoHelper{executorTaskInfoHelper_environmentExtra = executorTaskInfoHelper_environmentExtra obj} then P.Nothing else P.Just $ default_ExecutorTaskInfoHelper{executorTaskInfoHelper_environmentExtra = executorTaskInfoHelper_environmentExtra obj}
    , if obj == default_ExecutorTaskInfoHelper{executorTaskInfoHelper_dockerContainer = executorTaskInfoHelper_dockerContainer obj} then P.Nothing else P.Just $ default_ExecutorTaskInfoHelper{executorTaskInfoHelper_dockerContainer = executorTaskInfoHelper_dockerContainer obj}
    ]
from_ExecutorTaskInfoHelper :: ExecutorTaskInfoHelper -> T.ThriftVal
from_ExecutorTaskInfoHelper record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v42 -> P.Just (1, ("frameworkLoggingLevel",T.TI32 _v42))) $ executorTaskInfoHelper_frameworkLoggingLevel record
  , (\_v42 -> P.Just (2, ("user",T.TString $ E.encodeUtf8 _v42))) $ executorTaskInfoHelper_user record
  , (\_v42 -> P.Just (3, ("frameworkVModule",T.TString $ E.encodeUtf8 _v42))) $ executorTaskInfoHelper_frameworkVModule record
  , (\_v42 -> P.Just (4, ("scheduler",from_Endpoint _v42))) $ executorTaskInfoHelper_scheduler record
  , (\_v42 -> P.Just (5, ("proxy",from_Endpoint _v42))) $ executorTaskInfoHelper_proxy record
  , (\_v42 -> P.Just (6, ("client",from_Endpoint _v42))) $ executorTaskInfoHelper_client record
  , (\_v42 -> P.Just (7, ("traceAggregator",from_Endpoint _v42))) $ executorTaskInfoHelper_traceAggregator record
  , (\_v42 -> P.Just (8, ("execName",T.TString $ E.encodeUtf8 _v42))) $ executorTaskInfoHelper_execName record
  , (\_v42 -> P.Just (9, ("folder",T.TString $ E.encodeUtf8 _v42))) $ executorTaskInfoHelper_folder record
  , (\_v42 -> P.Just (10, ("computationAliasName",T.TString $ E.encodeUtf8 _v42))) $ executorTaskInfoHelper_computationAliasName record
  , (\_v42 -> P.Just (11, ("clientArguments",T.TList T.T_STRING $ P.map (\_v44 -> T.TString $ E.encodeUtf8 _v44) $ Vector.toList _v42))) $ executorTaskInfoHelper_clientArguments record
  , (\_v42 -> P.Just (12, ("environmentExtra",T.TList T.T_STRING $ P.map (\_v46 -> T.TString $ E.encodeUtf8 _v46) $ Vector.toList _v42))) $ executorTaskInfoHelper_environmentExtra record
  , (\_v42 -> P.Just (13, ("dockerContainer",T.TString $ E.encodeUtf8 _v42))) $ executorTaskInfoHelper_dockerContainer record
  ]
write_ExecutorTaskInfoHelper :: (T.Protocol p, T.Transport t) => p t -> ExecutorTaskInfoHelper -> P.IO ()
write_ExecutorTaskInfoHelper oprot record = T.writeVal oprot $ from_ExecutorTaskInfoHelper record
encode_ExecutorTaskInfoHelper :: (T.Protocol p, T.Transport t) => p t -> ExecutorTaskInfoHelper -> LBS.ByteString
encode_ExecutorTaskInfoHelper oprot record = T.serializeVal oprot $ from_ExecutorTaskInfoHelper record
to_ExecutorTaskInfoHelper :: T.ThriftVal -> ExecutorTaskInfoHelper
to_ExecutorTaskInfoHelper (T.TStruct fields) = ExecutorTaskInfoHelper{
  executorTaskInfoHelper_frameworkLoggingLevel = P.maybe (executorTaskInfoHelper_frameworkLoggingLevel default_ExecutorTaskInfoHelper) (\(_,_val48) -> (case _val48 of {T.TI32 _val49 -> _val49; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  executorTaskInfoHelper_user = P.maybe (executorTaskInfoHelper_user default_ExecutorTaskInfoHelper) (\(_,_val48) -> (case _val48 of {T.TString _val50 -> E.decodeUtf8 _val50; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  executorTaskInfoHelper_frameworkVModule = P.maybe (executorTaskInfoHelper_frameworkVModule default_ExecutorTaskInfoHelper) (\(_,_val48) -> (case _val48 of {T.TString _val51 -> E.decodeUtf8 _val51; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  executorTaskInfoHelper_scheduler = P.maybe (executorTaskInfoHelper_scheduler default_ExecutorTaskInfoHelper) (\(_,_val48) -> (case _val48 of {T.TStruct _val52 -> (to_Endpoint (T.TStruct _val52)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  executorTaskInfoHelper_proxy = P.maybe (executorTaskInfoHelper_proxy default_ExecutorTaskInfoHelper) (\(_,_val48) -> (case _val48 of {T.TStruct _val53 -> (to_Endpoint (T.TStruct _val53)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  executorTaskInfoHelper_client = P.maybe (executorTaskInfoHelper_client default_ExecutorTaskInfoHelper) (\(_,_val48) -> (case _val48 of {T.TStruct _val54 -> (to_Endpoint (T.TStruct _val54)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  executorTaskInfoHelper_traceAggregator = P.maybe (executorTaskInfoHelper_traceAggregator default_ExecutorTaskInfoHelper) (\(_,_val48) -> (case _val48 of {T.TStruct _val55 -> (to_Endpoint (T.TStruct _val55)); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  executorTaskInfoHelper_execName = P.maybe (executorTaskInfoHelper_execName default_ExecutorTaskInfoHelper) (\(_,_val48) -> (case _val48 of {T.TString _val56 -> E.decodeUtf8 _val56; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  executorTaskInfoHelper_folder = P.maybe (executorTaskInfoHelper_folder default_ExecutorTaskInfoHelper) (\(_,_val48) -> (case _val48 of {T.TString _val57 -> E.decodeUtf8 _val57; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  executorTaskInfoHelper_computationAliasName = P.maybe (executorTaskInfoHelper_computationAliasName default_ExecutorTaskInfoHelper) (\(_,_val48) -> (case _val48 of {T.TString _val58 -> E.decodeUtf8 _val58; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  executorTaskInfoHelper_clientArguments = P.maybe (executorTaskInfoHelper_clientArguments default_ExecutorTaskInfoHelper) (\(_,_val48) -> (case _val48 of {T.TList _ _val59 -> (Vector.fromList $ P.map (\_v60 -> (case _v60 of {T.TString _val61 -> E.decodeUtf8 _val61; _ -> P.error "wrong type"})) _val59); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  executorTaskInfoHelper_environmentExtra = P.maybe (executorTaskInfoHelper_environmentExtra default_ExecutorTaskInfoHelper) (\(_,_val48) -> (case _val48 of {T.TList _ _val62 -> (Vector.fromList $ P.map (\_v63 -> (case _v63 of {T.TString _val64 -> E.decodeUtf8 _val64; _ -> P.error "wrong type"})) _val62); _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  executorTaskInfoHelper_dockerContainer = P.maybe (executorTaskInfoHelper_dockerContainer default_ExecutorTaskInfoHelper) (\(_,_val48) -> (case _val48 of {T.TString _val65 -> E.decodeUtf8 _val65; _ -> P.error "wrong type"})) (Map.lookup (13) fields)
  }
to_ExecutorTaskInfoHelper _ = P.error "not a struct"
read_ExecutorTaskInfoHelper :: (T.Transport t, T.Protocol p) => p t -> P.IO ExecutorTaskInfoHelper
read_ExecutorTaskInfoHelper iprot = to_ExecutorTaskInfoHelper <$> T.readVal iprot (T.T_STRUCT typemap_ExecutorTaskInfoHelper)
decode_ExecutorTaskInfoHelper :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ExecutorTaskInfoHelper
decode_ExecutorTaskInfoHelper iprot bs = to_ExecutorTaskInfoHelper $ T.deserializeVal iprot (T.T_STRUCT typemap_ExecutorTaskInfoHelper) bs
typemap_ExecutorTaskInfoHelper :: T.TypeMap
typemap_ExecutorTaskInfoHelper = Map.fromList [(1,("frameworkLoggingLevel",T.T_I32)),(2,("user",T.T_STRING)),(3,("frameworkVModule",T.T_STRING)),(4,("scheduler",(T.T_STRUCT typemap_Endpoint))),(5,("proxy",(T.T_STRUCT typemap_Endpoint))),(6,("client",(T.T_STRUCT typemap_Endpoint))),(7,("traceAggregator",(T.T_STRUCT typemap_Endpoint))),(8,("execName",T.T_STRING)),(9,("folder",T.T_STRING)),(10,("computationAliasName",T.T_STRING)),(11,("clientArguments",(T.T_LIST T.T_STRING))),(12,("environmentExtra",(T.T_LIST T.T_STRING))),(13,("dockerContainer",T.T_STRING))]
default_ExecutorTaskInfoHelper :: ExecutorTaskInfoHelper
default_ExecutorTaskInfoHelper = ExecutorTaskInfoHelper{
  executorTaskInfoHelper_frameworkLoggingLevel = 1,
  executorTaskInfoHelper_user = "",
  executorTaskInfoHelper_frameworkVModule = "",
  executorTaskInfoHelper_scheduler = default_Endpoint,
  executorTaskInfoHelper_proxy = default_Endpoint,
  executorTaskInfoHelper_client = default_Endpoint,
  executorTaskInfoHelper_traceAggregator = default_Endpoint,
  executorTaskInfoHelper_execName = "",
  executorTaskInfoHelper_folder = "",
  executorTaskInfoHelper_computationAliasName = "",
  executorTaskInfoHelper_clientArguments = Vector.empty,
  executorTaskInfoHelper_environmentExtra = Vector.empty,
  executorTaskInfoHelper_dockerContainer = ""}
data PhysicalComputationMetadata = PhysicalComputationMetadata  { physicalComputationMetadata_taskId :: LT.Text
  , physicalComputationMetadata_slaveId :: LT.Text
  , physicalComputationMetadata_cpus :: P.Double
  , physicalComputationMetadata_mem :: I.Int32
  , physicalComputationMetadata_disk :: I.Int32
  , physicalComputationMetadata_taskHelper :: ExecutorTaskInfoHelper
  , physicalComputationMetadata_needsReconciliation :: P.Bool
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable PhysicalComputationMetadata where
  hashWithSalt salt record = salt   `H.hashWithSalt` physicalComputationMetadata_taskId record   `H.hashWithSalt` physicalComputationMetadata_slaveId record   `H.hashWithSalt` physicalComputationMetadata_cpus record   `H.hashWithSalt` physicalComputationMetadata_mem record   `H.hashWithSalt` physicalComputationMetadata_disk record   `H.hashWithSalt` physicalComputationMetadata_taskHelper record   `H.hashWithSalt` physicalComputationMetadata_needsReconciliation record  
instance QC.Arbitrary PhysicalComputationMetadata where 
  arbitrary = M.liftM PhysicalComputationMetadata (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PhysicalComputationMetadata = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PhysicalComputationMetadata{physicalComputationMetadata_taskId = physicalComputationMetadata_taskId obj} then P.Nothing else P.Just $ default_PhysicalComputationMetadata{physicalComputationMetadata_taskId = physicalComputationMetadata_taskId obj}
    , if obj == default_PhysicalComputationMetadata{physicalComputationMetadata_slaveId = physicalComputationMetadata_slaveId obj} then P.Nothing else P.Just $ default_PhysicalComputationMetadata{physicalComputationMetadata_slaveId = physicalComputationMetadata_slaveId obj}
    , if obj == default_PhysicalComputationMetadata{physicalComputationMetadata_cpus = physicalComputationMetadata_cpus obj} then P.Nothing else P.Just $ default_PhysicalComputationMetadata{physicalComputationMetadata_cpus = physicalComputationMetadata_cpus obj}
    , if obj == default_PhysicalComputationMetadata{physicalComputationMetadata_mem = physicalComputationMetadata_mem obj} then P.Nothing else P.Just $ default_PhysicalComputationMetadata{physicalComputationMetadata_mem = physicalComputationMetadata_mem obj}
    , if obj == default_PhysicalComputationMetadata{physicalComputationMetadata_disk = physicalComputationMetadata_disk obj} then P.Nothing else P.Just $ default_PhysicalComputationMetadata{physicalComputationMetadata_disk = physicalComputationMetadata_disk obj}
    , if obj == default_PhysicalComputationMetadata{physicalComputationMetadata_taskHelper = physicalComputationMetadata_taskHelper obj} then P.Nothing else P.Just $ default_PhysicalComputationMetadata{physicalComputationMetadata_taskHelper = physicalComputationMetadata_taskHelper obj}
    , if obj == default_PhysicalComputationMetadata{physicalComputationMetadata_needsReconciliation = physicalComputationMetadata_needsReconciliation obj} then P.Nothing else P.Just $ default_PhysicalComputationMetadata{physicalComputationMetadata_needsReconciliation = physicalComputationMetadata_needsReconciliation obj}
    ]
from_PhysicalComputationMetadata :: PhysicalComputationMetadata -> T.ThriftVal
from_PhysicalComputationMetadata record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v68 -> P.Just (1, ("taskId",T.TString $ E.encodeUtf8 _v68))) $ physicalComputationMetadata_taskId record
  , (\_v68 -> P.Just (2, ("slaveId",T.TString $ E.encodeUtf8 _v68))) $ physicalComputationMetadata_slaveId record
  , (\_v68 -> P.Just (3, ("cpus",T.TDouble _v68))) $ physicalComputationMetadata_cpus record
  , (\_v68 -> P.Just (4, ("mem",T.TI32 _v68))) $ physicalComputationMetadata_mem record
  , (\_v68 -> P.Just (5, ("disk",T.TI32 _v68))) $ physicalComputationMetadata_disk record
  , (\_v68 -> P.Just (6, ("taskHelper",from_ExecutorTaskInfoHelper _v68))) $ physicalComputationMetadata_taskHelper record
  , (\_v68 -> P.Just (7, ("needsReconciliation",T.TBool _v68))) $ physicalComputationMetadata_needsReconciliation record
  ]
write_PhysicalComputationMetadata :: (T.Protocol p, T.Transport t) => p t -> PhysicalComputationMetadata -> P.IO ()
write_PhysicalComputationMetadata oprot record = T.writeVal oprot $ from_PhysicalComputationMetadata record
encode_PhysicalComputationMetadata :: (T.Protocol p, T.Transport t) => p t -> PhysicalComputationMetadata -> LBS.ByteString
encode_PhysicalComputationMetadata oprot record = T.serializeVal oprot $ from_PhysicalComputationMetadata record
to_PhysicalComputationMetadata :: T.ThriftVal -> PhysicalComputationMetadata
to_PhysicalComputationMetadata (T.TStruct fields) = PhysicalComputationMetadata{
  physicalComputationMetadata_taskId = P.maybe (physicalComputationMetadata_taskId default_PhysicalComputationMetadata) (\(_,_val70) -> (case _val70 of {T.TString _val71 -> E.decodeUtf8 _val71; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  physicalComputationMetadata_slaveId = P.maybe (physicalComputationMetadata_slaveId default_PhysicalComputationMetadata) (\(_,_val70) -> (case _val70 of {T.TString _val72 -> E.decodeUtf8 _val72; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  physicalComputationMetadata_cpus = P.maybe (physicalComputationMetadata_cpus default_PhysicalComputationMetadata) (\(_,_val70) -> (case _val70 of {T.TDouble _val73 -> _val73; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  physicalComputationMetadata_mem = P.maybe (physicalComputationMetadata_mem default_PhysicalComputationMetadata) (\(_,_val70) -> (case _val70 of {T.TI32 _val74 -> _val74; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  physicalComputationMetadata_disk = P.maybe (physicalComputationMetadata_disk default_PhysicalComputationMetadata) (\(_,_val70) -> (case _val70 of {T.TI32 _val75 -> _val75; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  physicalComputationMetadata_taskHelper = P.maybe (physicalComputationMetadata_taskHelper default_PhysicalComputationMetadata) (\(_,_val70) -> (case _val70 of {T.TStruct _val76 -> (to_ExecutorTaskInfoHelper (T.TStruct _val76)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  physicalComputationMetadata_needsReconciliation = P.maybe (physicalComputationMetadata_needsReconciliation default_PhysicalComputationMetadata) (\(_,_val70) -> (case _val70 of {T.TBool _val77 -> _val77; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_PhysicalComputationMetadata _ = P.error "not a struct"
read_PhysicalComputationMetadata :: (T.Transport t, T.Protocol p) => p t -> P.IO PhysicalComputationMetadata
read_PhysicalComputationMetadata iprot = to_PhysicalComputationMetadata <$> T.readVal iprot (T.T_STRUCT typemap_PhysicalComputationMetadata)
decode_PhysicalComputationMetadata :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> PhysicalComputationMetadata
decode_PhysicalComputationMetadata iprot bs = to_PhysicalComputationMetadata $ T.deserializeVal iprot (T.T_STRUCT typemap_PhysicalComputationMetadata) bs
typemap_PhysicalComputationMetadata :: T.TypeMap
typemap_PhysicalComputationMetadata = Map.fromList [(1,("taskId",T.T_STRING)),(2,("slaveId",T.T_STRING)),(3,("cpus",T.T_DOUBLE)),(4,("mem",T.T_I32)),(5,("disk",T.T_I32)),(6,("taskHelper",(T.T_STRUCT typemap_ExecutorTaskInfoHelper))),(7,("needsReconciliation",T.T_BOOL))]
default_PhysicalComputationMetadata :: PhysicalComputationMetadata
default_PhysicalComputationMetadata = PhysicalComputationMetadata{
  physicalComputationMetadata_taskId = "",
  physicalComputationMetadata_slaveId = "",
  physicalComputationMetadata_cpus = 0,
  physicalComputationMetadata_mem = 0,
  physicalComputationMetadata_disk = 0,
  physicalComputationMetadata_taskHelper = default_ExecutorTaskInfoHelper,
  physicalComputationMetadata_needsReconciliation = P.False}
data PhysicalComputationLayout = PhysicalComputationLayout  { physicalComputationLayout_name :: LT.Text
  , physicalComputationLayout_istreams :: (Vector.Vector StreamMetadata)
  , physicalComputationLayout_ostreams :: (Vector.Vector LT.Text)
  , physicalComputationLayout_nodes :: (Vector.Vector PhysicalComputationMetadata)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable PhysicalComputationLayout where
  hashWithSalt salt record = salt   `H.hashWithSalt` physicalComputationLayout_name record   `H.hashWithSalt` physicalComputationLayout_istreams record   `H.hashWithSalt` physicalComputationLayout_ostreams record   `H.hashWithSalt` physicalComputationLayout_nodes record  
instance QC.Arbitrary PhysicalComputationLayout where 
  arbitrary = M.liftM PhysicalComputationLayout (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PhysicalComputationLayout = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PhysicalComputationLayout{physicalComputationLayout_name = physicalComputationLayout_name obj} then P.Nothing else P.Just $ default_PhysicalComputationLayout{physicalComputationLayout_name = physicalComputationLayout_name obj}
    , if obj == default_PhysicalComputationLayout{physicalComputationLayout_istreams = physicalComputationLayout_istreams obj} then P.Nothing else P.Just $ default_PhysicalComputationLayout{physicalComputationLayout_istreams = physicalComputationLayout_istreams obj}
    , if obj == default_PhysicalComputationLayout{physicalComputationLayout_ostreams = physicalComputationLayout_ostreams obj} then P.Nothing else P.Just $ default_PhysicalComputationLayout{physicalComputationLayout_ostreams = physicalComputationLayout_ostreams obj}
    , if obj == default_PhysicalComputationLayout{physicalComputationLayout_nodes = physicalComputationLayout_nodes obj} then P.Nothing else P.Just $ default_PhysicalComputationLayout{physicalComputationLayout_nodes = physicalComputationLayout_nodes obj}
    ]
from_PhysicalComputationLayout :: PhysicalComputationLayout -> T.ThriftVal
from_PhysicalComputationLayout record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v80 -> P.Just (1, ("name",T.TString $ E.encodeUtf8 _v80))) $ physicalComputationLayout_name record
  , (\_v80 -> P.Just (2, ("istreams",T.TList (T.T_STRUCT typemap_StreamMetadata) $ P.map (\_v82 -> from_StreamMetadata _v82) $ Vector.toList _v80))) $ physicalComputationLayout_istreams record
  , (\_v80 -> P.Just (3, ("ostreams",T.TList T.T_STRING $ P.map (\_v84 -> T.TString $ E.encodeUtf8 _v84) $ Vector.toList _v80))) $ physicalComputationLayout_ostreams record
  , (\_v80 -> P.Just (4, ("nodes",T.TList (T.T_STRUCT typemap_PhysicalComputationMetadata) $ P.map (\_v86 -> from_PhysicalComputationMetadata _v86) $ Vector.toList _v80))) $ physicalComputationLayout_nodes record
  ]
write_PhysicalComputationLayout :: (T.Protocol p, T.Transport t) => p t -> PhysicalComputationLayout -> P.IO ()
write_PhysicalComputationLayout oprot record = T.writeVal oprot $ from_PhysicalComputationLayout record
encode_PhysicalComputationLayout :: (T.Protocol p, T.Transport t) => p t -> PhysicalComputationLayout -> LBS.ByteString
encode_PhysicalComputationLayout oprot record = T.serializeVal oprot $ from_PhysicalComputationLayout record
to_PhysicalComputationLayout :: T.ThriftVal -> PhysicalComputationLayout
to_PhysicalComputationLayout (T.TStruct fields) = PhysicalComputationLayout{
  physicalComputationLayout_name = P.maybe (physicalComputationLayout_name default_PhysicalComputationLayout) (\(_,_val88) -> (case _val88 of {T.TString _val89 -> E.decodeUtf8 _val89; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  physicalComputationLayout_istreams = P.maybe (physicalComputationLayout_istreams default_PhysicalComputationLayout) (\(_,_val88) -> (case _val88 of {T.TList _ _val90 -> (Vector.fromList $ P.map (\_v91 -> (case _v91 of {T.TStruct _val92 -> (to_StreamMetadata (T.TStruct _val92)); _ -> P.error "wrong type"})) _val90); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  physicalComputationLayout_ostreams = P.maybe (physicalComputationLayout_ostreams default_PhysicalComputationLayout) (\(_,_val88) -> (case _val88 of {T.TList _ _val93 -> (Vector.fromList $ P.map (\_v94 -> (case _v94 of {T.TString _val95 -> E.decodeUtf8 _val95; _ -> P.error "wrong type"})) _val93); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  physicalComputationLayout_nodes = P.maybe (physicalComputationLayout_nodes default_PhysicalComputationLayout) (\(_,_val88) -> (case _val88 of {T.TList _ _val96 -> (Vector.fromList $ P.map (\_v97 -> (case _v97 of {T.TStruct _val98 -> (to_PhysicalComputationMetadata (T.TStruct _val98)); _ -> P.error "wrong type"})) _val96); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_PhysicalComputationLayout _ = P.error "not a struct"
read_PhysicalComputationLayout :: (T.Transport t, T.Protocol p) => p t -> P.IO PhysicalComputationLayout
read_PhysicalComputationLayout iprot = to_PhysicalComputationLayout <$> T.readVal iprot (T.T_STRUCT typemap_PhysicalComputationLayout)
decode_PhysicalComputationLayout :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> PhysicalComputationLayout
decode_PhysicalComputationLayout iprot bs = to_PhysicalComputationLayout $ T.deserializeVal iprot (T.T_STRUCT typemap_PhysicalComputationLayout) bs
typemap_PhysicalComputationLayout :: T.TypeMap
typemap_PhysicalComputationLayout = Map.fromList [(1,("name",T.T_STRING)),(2,("istreams",(T.T_LIST (T.T_STRUCT typemap_StreamMetadata)))),(3,("ostreams",(T.T_LIST T.T_STRING))),(4,("nodes",(T.T_LIST (T.T_STRUCT typemap_PhysicalComputationMetadata))))]
default_PhysicalComputationLayout :: PhysicalComputationLayout
default_PhysicalComputationLayout = PhysicalComputationLayout{
  physicalComputationLayout_name = "",
  physicalComputationLayout_istreams = Vector.empty,
  physicalComputationLayout_ostreams = Vector.empty,
  physicalComputationLayout_nodes = Vector.empty}
data SchedulerMetadata = SchedulerMetadata  { schedulerMetadata_endpoint :: Endpoint
  , schedulerMetadata_version :: I.Int32
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable SchedulerMetadata where
  hashWithSalt salt record = salt   `H.hashWithSalt` schedulerMetadata_endpoint record   `H.hashWithSalt` schedulerMetadata_version record  
instance QC.Arbitrary SchedulerMetadata where 
  arbitrary = M.liftM SchedulerMetadata (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SchedulerMetadata = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SchedulerMetadata{schedulerMetadata_endpoint = schedulerMetadata_endpoint obj} then P.Nothing else P.Just $ default_SchedulerMetadata{schedulerMetadata_endpoint = schedulerMetadata_endpoint obj}
    , if obj == default_SchedulerMetadata{schedulerMetadata_version = schedulerMetadata_version obj} then P.Nothing else P.Just $ default_SchedulerMetadata{schedulerMetadata_version = schedulerMetadata_version obj}
    ]
from_SchedulerMetadata :: SchedulerMetadata -> T.ThriftVal
from_SchedulerMetadata record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v101 -> P.Just (1, ("endpoint",from_Endpoint _v101))) $ schedulerMetadata_endpoint record
  , (\_v101 -> P.Just (2, ("version",T.TI32 _v101))) $ schedulerMetadata_version record
  ]
write_SchedulerMetadata :: (T.Protocol p, T.Transport t) => p t -> SchedulerMetadata -> P.IO ()
write_SchedulerMetadata oprot record = T.writeVal oprot $ from_SchedulerMetadata record
encode_SchedulerMetadata :: (T.Protocol p, T.Transport t) => p t -> SchedulerMetadata -> LBS.ByteString
encode_SchedulerMetadata oprot record = T.serializeVal oprot $ from_SchedulerMetadata record
to_SchedulerMetadata :: T.ThriftVal -> SchedulerMetadata
to_SchedulerMetadata (T.TStruct fields) = SchedulerMetadata{
  schedulerMetadata_endpoint = P.maybe (schedulerMetadata_endpoint default_SchedulerMetadata) (\(_,_val103) -> (case _val103 of {T.TStruct _val104 -> (to_Endpoint (T.TStruct _val104)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  schedulerMetadata_version = P.maybe (schedulerMetadata_version default_SchedulerMetadata) (\(_,_val103) -> (case _val103 of {T.TI32 _val105 -> _val105; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SchedulerMetadata _ = P.error "not a struct"
read_SchedulerMetadata :: (T.Transport t, T.Protocol p) => p t -> P.IO SchedulerMetadata
read_SchedulerMetadata iprot = to_SchedulerMetadata <$> T.readVal iprot (T.T_STRUCT typemap_SchedulerMetadata)
decode_SchedulerMetadata :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SchedulerMetadata
decode_SchedulerMetadata iprot bs = to_SchedulerMetadata $ T.deserializeVal iprot (T.T_STRUCT typemap_SchedulerMetadata) bs
typemap_SchedulerMetadata :: T.TypeMap
typemap_SchedulerMetadata = Map.fromList [(1,("endpoint",(T.T_STRUCT typemap_Endpoint))),(2,("version",T.T_I32))]
default_SchedulerMetadata :: SchedulerMetadata
default_SchedulerMetadata = SchedulerMetadata{
  schedulerMetadata_endpoint = default_Endpoint,
  schedulerMetadata_version = 0}
data TopologyMetadata = TopologyMetadata  { topologyMetadata_version :: I.Int32
  , topologyMetadata_computations :: (Map.HashMap LT.Text PhysicalComputationLayout)
  , topologyMetadata_frameworkID :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable TopologyMetadata where
  hashWithSalt salt record = salt   `H.hashWithSalt` topologyMetadata_version record   `H.hashWithSalt` topologyMetadata_computations record   `H.hashWithSalt` topologyMetadata_frameworkID record  
instance QC.Arbitrary TopologyMetadata where 
  arbitrary = M.liftM TopologyMetadata (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TopologyMetadata = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TopologyMetadata{topologyMetadata_version = topologyMetadata_version obj} then P.Nothing else P.Just $ default_TopologyMetadata{topologyMetadata_version = topologyMetadata_version obj}
    , if obj == default_TopologyMetadata{topologyMetadata_computations = topologyMetadata_computations obj} then P.Nothing else P.Just $ default_TopologyMetadata{topologyMetadata_computations = topologyMetadata_computations obj}
    , if obj == default_TopologyMetadata{topologyMetadata_frameworkID = topologyMetadata_frameworkID obj} then P.Nothing else P.Just $ default_TopologyMetadata{topologyMetadata_frameworkID = topologyMetadata_frameworkID obj}
    ]
from_TopologyMetadata :: TopologyMetadata -> T.ThriftVal
from_TopologyMetadata record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v108 -> P.Just (1, ("version",T.TI32 _v108))) $ topologyMetadata_version record
  , (\_v108 -> P.Just (2, ("computations",T.TMap T.T_STRING (T.T_STRUCT typemap_PhysicalComputationLayout) $ P.map (\(_k109,_v110) -> (T.TString $ E.encodeUtf8 _k109, from_PhysicalComputationLayout _v110)) $ Map.toList _v108))) $ topologyMetadata_computations record
  , (\_v108 -> P.Just (3, ("frameworkID",T.TString $ E.encodeUtf8 _v108))) $ topologyMetadata_frameworkID record
  ]
write_TopologyMetadata :: (T.Protocol p, T.Transport t) => p t -> TopologyMetadata -> P.IO ()
write_TopologyMetadata oprot record = T.writeVal oprot $ from_TopologyMetadata record
encode_TopologyMetadata :: (T.Protocol p, T.Transport t) => p t -> TopologyMetadata -> LBS.ByteString
encode_TopologyMetadata oprot record = T.serializeVal oprot $ from_TopologyMetadata record
to_TopologyMetadata :: T.ThriftVal -> TopologyMetadata
to_TopologyMetadata (T.TStruct fields) = TopologyMetadata{
  topologyMetadata_version = P.maybe (topologyMetadata_version default_TopologyMetadata) (\(_,_val112) -> (case _val112 of {T.TI32 _val113 -> _val113; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  topologyMetadata_computations = P.maybe (topologyMetadata_computations default_TopologyMetadata) (\(_,_val112) -> (case _val112 of {T.TMap _ _ _val114 -> (Map.fromList $ P.map (\(_k116,_v115) -> ((case _k116 of {T.TString _val117 -> E.decodeUtf8 _val117; _ -> P.error "wrong type"}),(case _v115 of {T.TStruct _val118 -> (to_PhysicalComputationLayout (T.TStruct _val118)); _ -> P.error "wrong type"}))) _val114); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  topologyMetadata_frameworkID = P.maybe (topologyMetadata_frameworkID default_TopologyMetadata) (\(_,_val112) -> (case _val112 of {T.TString _val119 -> E.decodeUtf8 _val119; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_TopologyMetadata _ = P.error "not a struct"
read_TopologyMetadata :: (T.Transport t, T.Protocol p) => p t -> P.IO TopologyMetadata
read_TopologyMetadata iprot = to_TopologyMetadata <$> T.readVal iprot (T.T_STRUCT typemap_TopologyMetadata)
decode_TopologyMetadata :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TopologyMetadata
decode_TopologyMetadata iprot bs = to_TopologyMetadata $ T.deserializeVal iprot (T.T_STRUCT typemap_TopologyMetadata) bs
typemap_TopologyMetadata :: T.TypeMap
typemap_TopologyMetadata = Map.fromList [(1,("version",T.T_I32)),(2,("computations",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_PhysicalComputationLayout)))),(3,("frameworkID",T.T_STRING))]
default_TopologyMetadata :: TopologyMetadata
default_TopologyMetadata = TopologyMetadata{
  topologyMetadata_version = 0,
  topologyMetadata_computations = Map.empty,
  topologyMetadata_frameworkID = ""}
data RecordMetadata = RecordMetadata  { recordMetadata_traceId :: I.Int64
  , recordMetadata_sourceSpanId :: I.Int64
  , recordMetadata_flags :: I.Int32
  , recordMetadata_stream :: I.Int64
  , recordMetadata_timestamp :: I.Int64
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable RecordMetadata where
  hashWithSalt salt record = salt   `H.hashWithSalt` recordMetadata_traceId record   `H.hashWithSalt` recordMetadata_sourceSpanId record   `H.hashWithSalt` recordMetadata_flags record   `H.hashWithSalt` recordMetadata_stream record   `H.hashWithSalt` recordMetadata_timestamp record  
instance QC.Arbitrary RecordMetadata where 
  arbitrary = M.liftM RecordMetadata (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RecordMetadata = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RecordMetadata{recordMetadata_traceId = recordMetadata_traceId obj} then P.Nothing else P.Just $ default_RecordMetadata{recordMetadata_traceId = recordMetadata_traceId obj}
    , if obj == default_RecordMetadata{recordMetadata_sourceSpanId = recordMetadata_sourceSpanId obj} then P.Nothing else P.Just $ default_RecordMetadata{recordMetadata_sourceSpanId = recordMetadata_sourceSpanId obj}
    , if obj == default_RecordMetadata{recordMetadata_flags = recordMetadata_flags obj} then P.Nothing else P.Just $ default_RecordMetadata{recordMetadata_flags = recordMetadata_flags obj}
    , if obj == default_RecordMetadata{recordMetadata_stream = recordMetadata_stream obj} then P.Nothing else P.Just $ default_RecordMetadata{recordMetadata_stream = recordMetadata_stream obj}
    , if obj == default_RecordMetadata{recordMetadata_timestamp = recordMetadata_timestamp obj} then P.Nothing else P.Just $ default_RecordMetadata{recordMetadata_timestamp = recordMetadata_timestamp obj}
    ]
from_RecordMetadata :: RecordMetadata -> T.ThriftVal
from_RecordMetadata record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v122 -> P.Just (1, ("traceId",T.TI64 _v122))) $ recordMetadata_traceId record
  , (\_v122 -> P.Just (2, ("sourceSpanId",T.TI64 _v122))) $ recordMetadata_sourceSpanId record
  , (\_v122 -> P.Just (3, ("flags",T.TI32 _v122))) $ recordMetadata_flags record
  , (\_v122 -> P.Just (4, ("stream",T.TI64 _v122))) $ recordMetadata_stream record
  , (\_v122 -> P.Just (5, ("timestamp",T.TI64 _v122))) $ recordMetadata_timestamp record
  ]
write_RecordMetadata :: (T.Protocol p, T.Transport t) => p t -> RecordMetadata -> P.IO ()
write_RecordMetadata oprot record = T.writeVal oprot $ from_RecordMetadata record
encode_RecordMetadata :: (T.Protocol p, T.Transport t) => p t -> RecordMetadata -> LBS.ByteString
encode_RecordMetadata oprot record = T.serializeVal oprot $ from_RecordMetadata record
to_RecordMetadata :: T.ThriftVal -> RecordMetadata
to_RecordMetadata (T.TStruct fields) = RecordMetadata{
  recordMetadata_traceId = P.maybe (recordMetadata_traceId default_RecordMetadata) (\(_,_val124) -> (case _val124 of {T.TI64 _val125 -> _val125; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  recordMetadata_sourceSpanId = P.maybe (recordMetadata_sourceSpanId default_RecordMetadata) (\(_,_val124) -> (case _val124 of {T.TI64 _val126 -> _val126; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  recordMetadata_flags = P.maybe (recordMetadata_flags default_RecordMetadata) (\(_,_val124) -> (case _val124 of {T.TI32 _val127 -> _val127; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  recordMetadata_stream = P.maybe (recordMetadata_stream default_RecordMetadata) (\(_,_val124) -> (case _val124 of {T.TI64 _val128 -> _val128; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  recordMetadata_timestamp = P.maybe (recordMetadata_timestamp default_RecordMetadata) (\(_,_val124) -> (case _val124 of {T.TI64 _val129 -> _val129; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_RecordMetadata _ = P.error "not a struct"
read_RecordMetadata :: (T.Transport t, T.Protocol p) => p t -> P.IO RecordMetadata
read_RecordMetadata iprot = to_RecordMetadata <$> T.readVal iprot (T.T_STRUCT typemap_RecordMetadata)
decode_RecordMetadata :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> RecordMetadata
decode_RecordMetadata iprot bs = to_RecordMetadata $ T.deserializeVal iprot (T.T_STRUCT typemap_RecordMetadata) bs
typemap_RecordMetadata :: T.TypeMap
typemap_RecordMetadata = Map.fromList [(1,("traceId",T.T_I64)),(2,("sourceSpanId",T.T_I64)),(3,("flags",T.T_I32)),(4,("stream",T.T_I64)),(5,("timestamp",T.T_I64))]
default_RecordMetadata :: RecordMetadata
default_RecordMetadata = RecordMetadata{
  recordMetadata_traceId = 0,
  recordMetadata_sourceSpanId = 0,
  recordMetadata_flags = 0,
  recordMetadata_stream = 0,
  recordMetadata_timestamp = 0}
data Record = Record  { record_meta :: RecordMetadata
  , record_time :: I.Int64
  , record_key :: LBS.ByteString
  , record_data :: LBS.ByteString
  , record_userStream :: LBS.ByteString
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Record where
  hashWithSalt salt record = salt   `H.hashWithSalt` record_meta record   `H.hashWithSalt` record_time record   `H.hashWithSalt` record_key record   `H.hashWithSalt` record_data record   `H.hashWithSalt` record_userStream record  
instance QC.Arbitrary Record where 
  arbitrary = M.liftM Record (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Record = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Record{record_meta = record_meta obj} then P.Nothing else P.Just $ default_Record{record_meta = record_meta obj}
    , if obj == default_Record{record_time = record_time obj} then P.Nothing else P.Just $ default_Record{record_time = record_time obj}
    , if obj == default_Record{record_key = record_key obj} then P.Nothing else P.Just $ default_Record{record_key = record_key obj}
    , if obj == default_Record{record_data = record_data obj} then P.Nothing else P.Just $ default_Record{record_data = record_data obj}
    , if obj == default_Record{record_userStream = record_userStream obj} then P.Nothing else P.Just $ default_Record{record_userStream = record_userStream obj}
    ]
from_Record :: Record -> T.ThriftVal
from_Record record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v132 -> P.Just (1, ("meta",from_RecordMetadata _v132))) $ record_meta record
  , (\_v132 -> P.Just (2, ("time",T.TI64 _v132))) $ record_time record
  , (\_v132 -> P.Just (3, ("key",T.TString _v132))) $ record_key record
  , (\_v132 -> P.Just (4, ("data",T.TString _v132))) $ record_data record
  , (\_v132 -> P.Just (5, ("userStream",T.TString _v132))) $ record_userStream record
  ]
write_Record :: (T.Protocol p, T.Transport t) => p t -> Record -> P.IO ()
write_Record oprot record = T.writeVal oprot $ from_Record record
encode_Record :: (T.Protocol p, T.Transport t) => p t -> Record -> LBS.ByteString
encode_Record oprot record = T.serializeVal oprot $ from_Record record
to_Record :: T.ThriftVal -> Record
to_Record (T.TStruct fields) = Record{
  record_meta = P.maybe (record_meta default_Record) (\(_,_val134) -> (case _val134 of {T.TStruct _val135 -> (to_RecordMetadata (T.TStruct _val135)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  record_time = P.maybe (record_time default_Record) (\(_,_val134) -> (case _val134 of {T.TI64 _val136 -> _val136; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  record_key = P.maybe (record_key default_Record) (\(_,_val134) -> (case _val134 of {T.TString _val137 -> _val137; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  record_data = P.maybe (record_data default_Record) (\(_,_val134) -> (case _val134 of {T.TString _val138 -> _val138; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  record_userStream = P.maybe (record_userStream default_Record) (\(_,_val134) -> (case _val134 of {T.TString _val139 -> _val139; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_Record _ = P.error "not a struct"
read_Record :: (T.Transport t, T.Protocol p) => p t -> P.IO Record
read_Record iprot = to_Record <$> T.readVal iprot (T.T_STRUCT typemap_Record)
decode_Record :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Record
decode_Record iprot bs = to_Record $ T.deserializeVal iprot (T.T_STRUCT typemap_Record) bs
typemap_Record :: T.TypeMap
typemap_Record = Map.fromList [(1,("meta",(T.T_STRUCT typemap_RecordMetadata))),(2,("time",T.T_I64)),(3,("key",T.T_STRING)),(4,("data",T.T_STRING)),(5,("userStream",T.T_STRING))]
default_Record :: Record
default_Record = Record{
  record_meta = default_RecordMetadata,
  record_time = 0,
  record_key = "",
  record_data = "",
  record_userStream = ""}
data ComputationTx = ComputationTx  { computationTx_id :: I.Int64
  , computationTx_records :: (Vector.Vector Record)
  , computationTx_timers :: (Map.HashMap LT.Text I.Int64)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable ComputationTx where
  hashWithSalt salt record = salt   `H.hashWithSalt` computationTx_id record   `H.hashWithSalt` computationTx_records record   `H.hashWithSalt` computationTx_timers record  
instance QC.Arbitrary ComputationTx where 
  arbitrary = M.liftM ComputationTx (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ComputationTx = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ComputationTx{computationTx_id = computationTx_id obj} then P.Nothing else P.Just $ default_ComputationTx{computationTx_id = computationTx_id obj}
    , if obj == default_ComputationTx{computationTx_records = computationTx_records obj} then P.Nothing else P.Just $ default_ComputationTx{computationTx_records = computationTx_records obj}
    , if obj == default_ComputationTx{computationTx_timers = computationTx_timers obj} then P.Nothing else P.Just $ default_ComputationTx{computationTx_timers = computationTx_timers obj}
    ]
from_ComputationTx :: ComputationTx -> T.ThriftVal
from_ComputationTx record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v142 -> P.Just (1, ("id",T.TI64 _v142))) $ computationTx_id record
  , (\_v142 -> P.Just (2, ("records",T.TList (T.T_STRUCT typemap_Record) $ P.map (\_v144 -> from_Record _v144) $ Vector.toList _v142))) $ computationTx_records record
  , (\_v142 -> P.Just (3, ("timers",T.TMap T.T_STRING T.T_I64 $ P.map (\(_k145,_v146) -> (T.TString $ E.encodeUtf8 _k145, T.TI64 _v146)) $ Map.toList _v142))) $ computationTx_timers record
  ]
write_ComputationTx :: (T.Protocol p, T.Transport t) => p t -> ComputationTx -> P.IO ()
write_ComputationTx oprot record = T.writeVal oprot $ from_ComputationTx record
encode_ComputationTx :: (T.Protocol p, T.Transport t) => p t -> ComputationTx -> LBS.ByteString
encode_ComputationTx oprot record = T.serializeVal oprot $ from_ComputationTx record
to_ComputationTx :: T.ThriftVal -> ComputationTx
to_ComputationTx (T.TStruct fields) = ComputationTx{
  computationTx_id = P.maybe (computationTx_id default_ComputationTx) (\(_,_val148) -> (case _val148 of {T.TI64 _val149 -> _val149; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  computationTx_records = P.maybe (computationTx_records default_ComputationTx) (\(_,_val148) -> (case _val148 of {T.TList _ _val150 -> (Vector.fromList $ P.map (\_v151 -> (case _v151 of {T.TStruct _val152 -> (to_Record (T.TStruct _val152)); _ -> P.error "wrong type"})) _val150); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  computationTx_timers = P.maybe (computationTx_timers default_ComputationTx) (\(_,_val148) -> (case _val148 of {T.TMap _ _ _val153 -> (Map.fromList $ P.map (\(_k155,_v154) -> ((case _k155 of {T.TString _val156 -> E.decodeUtf8 _val156; _ -> P.error "wrong type"}),(case _v154 of {T.TI64 _val157 -> _val157; _ -> P.error "wrong type"}))) _val153); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ComputationTx _ = P.error "not a struct"
read_ComputationTx :: (T.Transport t, T.Protocol p) => p t -> P.IO ComputationTx
read_ComputationTx iprot = to_ComputationTx <$> T.readVal iprot (T.T_STRUCT typemap_ComputationTx)
decode_ComputationTx :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ComputationTx
decode_ComputationTx iprot bs = to_ComputationTx $ T.deserializeVal iprot (T.T_STRUCT typemap_ComputationTx) bs
typemap_ComputationTx :: T.TypeMap
typemap_ComputationTx = Map.fromList [(1,("id",T.T_I64)),(2,("records",(T.T_LIST (T.T_STRUCT typemap_Record)))),(3,("timers",(T.T_MAP T.T_STRING T.T_I64)))]
default_ComputationTx :: ComputationTx
default_ComputationTx = ComputationTx{
  computationTx_id = 0,
  computationTx_records = Vector.empty,
  computationTx_timers = Map.empty}
data RichStream = RichStream  { richStream_stream :: StreamMetadata
  , richStream_computationName :: LT.Text
  , richStream_endpoints :: (Vector.Vector Endpoint)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable RichStream where
  hashWithSalt salt record = salt   `H.hashWithSalt` richStream_stream record   `H.hashWithSalt` richStream_computationName record   `H.hashWithSalt` richStream_endpoints record  
instance QC.Arbitrary RichStream where 
  arbitrary = M.liftM RichStream (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RichStream = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RichStream{richStream_stream = richStream_stream obj} then P.Nothing else P.Just $ default_RichStream{richStream_stream = richStream_stream obj}
    , if obj == default_RichStream{richStream_computationName = richStream_computationName obj} then P.Nothing else P.Just $ default_RichStream{richStream_computationName = richStream_computationName obj}
    , if obj == default_RichStream{richStream_endpoints = richStream_endpoints obj} then P.Nothing else P.Just $ default_RichStream{richStream_endpoints = richStream_endpoints obj}
    ]
from_RichStream :: RichStream -> T.ThriftVal
from_RichStream record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v160 -> P.Just (1, ("stream",from_StreamMetadata _v160))) $ richStream_stream record
  , (\_v160 -> P.Just (2, ("computationName",T.TString $ E.encodeUtf8 _v160))) $ richStream_computationName record
  , (\_v160 -> P.Just (3, ("endpoints",T.TList (T.T_STRUCT typemap_Endpoint) $ P.map (\_v162 -> from_Endpoint _v162) $ Vector.toList _v160))) $ richStream_endpoints record
  ]
write_RichStream :: (T.Protocol p, T.Transport t) => p t -> RichStream -> P.IO ()
write_RichStream oprot record = T.writeVal oprot $ from_RichStream record
encode_RichStream :: (T.Protocol p, T.Transport t) => p t -> RichStream -> LBS.ByteString
encode_RichStream oprot record = T.serializeVal oprot $ from_RichStream record
to_RichStream :: T.ThriftVal -> RichStream
to_RichStream (T.TStruct fields) = RichStream{
  richStream_stream = P.maybe (richStream_stream default_RichStream) (\(_,_val164) -> (case _val164 of {T.TStruct _val165 -> (to_StreamMetadata (T.TStruct _val165)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  richStream_computationName = P.maybe (richStream_computationName default_RichStream) (\(_,_val164) -> (case _val164 of {T.TString _val166 -> E.decodeUtf8 _val166; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  richStream_endpoints = P.maybe (richStream_endpoints default_RichStream) (\(_,_val164) -> (case _val164 of {T.TList _ _val167 -> (Vector.fromList $ P.map (\_v168 -> (case _v168 of {T.TStruct _val169 -> (to_Endpoint (T.TStruct _val169)); _ -> P.error "wrong type"})) _val167); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RichStream _ = P.error "not a struct"
read_RichStream :: (T.Transport t, T.Protocol p) => p t -> P.IO RichStream
read_RichStream iprot = to_RichStream <$> T.readVal iprot (T.T_STRUCT typemap_RichStream)
decode_RichStream :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> RichStream
decode_RichStream iprot bs = to_RichStream $ T.deserializeVal iprot (T.T_STRUCT typemap_RichStream) bs
typemap_RichStream :: T.TypeMap
typemap_RichStream = Map.fromList [(1,("stream",(T.T_STRUCT typemap_StreamMetadata))),(2,("computationName",T.T_STRING)),(3,("endpoints",(T.T_LIST (T.T_STRUCT typemap_Endpoint))))]
default_RichStream :: RichStream
default_RichStream = RichStream{
  richStream_stream = default_StreamMetadata,
  richStream_computationName = "",
  richStream_endpoints = Vector.empty}
data BoltComputationRequest = BoltComputationRequest  { boltComputationRequest_name :: LT.Text
  , boltComputationRequest_instances :: I.Int64
  , boltComputationRequest_cpus :: P.Double
  , boltComputationRequest_mem :: I.Int64
  , boltComputationRequest_disk :: I.Int64
  , boltComputationRequest_taskHelper :: ExecutorTaskInfoHelper
  , boltComputationRequest_forceUpdateBinary :: P.Bool
  , boltComputationRequest_slug :: LBS.ByteString
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable BoltComputationRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` boltComputationRequest_name record   `H.hashWithSalt` boltComputationRequest_instances record   `H.hashWithSalt` boltComputationRequest_cpus record   `H.hashWithSalt` boltComputationRequest_mem record   `H.hashWithSalt` boltComputationRequest_disk record   `H.hashWithSalt` boltComputationRequest_taskHelper record   `H.hashWithSalt` boltComputationRequest_forceUpdateBinary record   `H.hashWithSalt` boltComputationRequest_slug record  
instance QC.Arbitrary BoltComputationRequest where 
  arbitrary = M.liftM BoltComputationRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BoltComputationRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BoltComputationRequest{boltComputationRequest_name = boltComputationRequest_name obj} then P.Nothing else P.Just $ default_BoltComputationRequest{boltComputationRequest_name = boltComputationRequest_name obj}
    , if obj == default_BoltComputationRequest{boltComputationRequest_instances = boltComputationRequest_instances obj} then P.Nothing else P.Just $ default_BoltComputationRequest{boltComputationRequest_instances = boltComputationRequest_instances obj}
    , if obj == default_BoltComputationRequest{boltComputationRequest_cpus = boltComputationRequest_cpus obj} then P.Nothing else P.Just $ default_BoltComputationRequest{boltComputationRequest_cpus = boltComputationRequest_cpus obj}
    , if obj == default_BoltComputationRequest{boltComputationRequest_mem = boltComputationRequest_mem obj} then P.Nothing else P.Just $ default_BoltComputationRequest{boltComputationRequest_mem = boltComputationRequest_mem obj}
    , if obj == default_BoltComputationRequest{boltComputationRequest_disk = boltComputationRequest_disk obj} then P.Nothing else P.Just $ default_BoltComputationRequest{boltComputationRequest_disk = boltComputationRequest_disk obj}
    , if obj == default_BoltComputationRequest{boltComputationRequest_taskHelper = boltComputationRequest_taskHelper obj} then P.Nothing else P.Just $ default_BoltComputationRequest{boltComputationRequest_taskHelper = boltComputationRequest_taskHelper obj}
    , if obj == default_BoltComputationRequest{boltComputationRequest_forceUpdateBinary = boltComputationRequest_forceUpdateBinary obj} then P.Nothing else P.Just $ default_BoltComputationRequest{boltComputationRequest_forceUpdateBinary = boltComputationRequest_forceUpdateBinary obj}
    , if obj == default_BoltComputationRequest{boltComputationRequest_slug = boltComputationRequest_slug obj} then P.Nothing else P.Just $ default_BoltComputationRequest{boltComputationRequest_slug = boltComputationRequest_slug obj}
    ]
from_BoltComputationRequest :: BoltComputationRequest -> T.ThriftVal
from_BoltComputationRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v172 -> P.Just (1, ("name",T.TString $ E.encodeUtf8 _v172))) $ boltComputationRequest_name record
  , (\_v172 -> P.Just (2, ("instances",T.TI64 _v172))) $ boltComputationRequest_instances record
  , (\_v172 -> P.Just (3, ("cpus",T.TDouble _v172))) $ boltComputationRequest_cpus record
  , (\_v172 -> P.Just (4, ("mem",T.TI64 _v172))) $ boltComputationRequest_mem record
  , (\_v172 -> P.Just (5, ("disk",T.TI64 _v172))) $ boltComputationRequest_disk record
  , (\_v172 -> P.Just (6, ("taskHelper",from_ExecutorTaskInfoHelper _v172))) $ boltComputationRequest_taskHelper record
  , (\_v172 -> P.Just (7, ("forceUpdateBinary",T.TBool _v172))) $ boltComputationRequest_forceUpdateBinary record
  , (\_v172 -> P.Just (8, ("slug",T.TString _v172))) $ boltComputationRequest_slug record
  ]
write_BoltComputationRequest :: (T.Protocol p, T.Transport t) => p t -> BoltComputationRequest -> P.IO ()
write_BoltComputationRequest oprot record = T.writeVal oprot $ from_BoltComputationRequest record
encode_BoltComputationRequest :: (T.Protocol p, T.Transport t) => p t -> BoltComputationRequest -> LBS.ByteString
encode_BoltComputationRequest oprot record = T.serializeVal oprot $ from_BoltComputationRequest record
to_BoltComputationRequest :: T.ThriftVal -> BoltComputationRequest
to_BoltComputationRequest (T.TStruct fields) = BoltComputationRequest{
  boltComputationRequest_name = P.maybe (boltComputationRequest_name default_BoltComputationRequest) (\(_,_val174) -> (case _val174 of {T.TString _val175 -> E.decodeUtf8 _val175; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  boltComputationRequest_instances = P.maybe (boltComputationRequest_instances default_BoltComputationRequest) (\(_,_val174) -> (case _val174 of {T.TI64 _val176 -> _val176; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  boltComputationRequest_cpus = P.maybe (boltComputationRequest_cpus default_BoltComputationRequest) (\(_,_val174) -> (case _val174 of {T.TDouble _val177 -> _val177; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  boltComputationRequest_mem = P.maybe (boltComputationRequest_mem default_BoltComputationRequest) (\(_,_val174) -> (case _val174 of {T.TI64 _val178 -> _val178; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  boltComputationRequest_disk = P.maybe (boltComputationRequest_disk default_BoltComputationRequest) (\(_,_val174) -> (case _val174 of {T.TI64 _val179 -> _val179; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  boltComputationRequest_taskHelper = P.maybe (boltComputationRequest_taskHelper default_BoltComputationRequest) (\(_,_val174) -> (case _val174 of {T.TStruct _val180 -> (to_ExecutorTaskInfoHelper (T.TStruct _val180)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  boltComputationRequest_forceUpdateBinary = P.maybe (boltComputationRequest_forceUpdateBinary default_BoltComputationRequest) (\(_,_val174) -> (case _val174 of {T.TBool _val181 -> _val181; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  boltComputationRequest_slug = P.maybe (boltComputationRequest_slug default_BoltComputationRequest) (\(_,_val174) -> (case _val174 of {T.TString _val182 -> _val182; _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_BoltComputationRequest _ = P.error "not a struct"
read_BoltComputationRequest :: (T.Transport t, T.Protocol p) => p t -> P.IO BoltComputationRequest
read_BoltComputationRequest iprot = to_BoltComputationRequest <$> T.readVal iprot (T.T_STRUCT typemap_BoltComputationRequest)
decode_BoltComputationRequest :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> BoltComputationRequest
decode_BoltComputationRequest iprot bs = to_BoltComputationRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_BoltComputationRequest) bs
typemap_BoltComputationRequest :: T.TypeMap
typemap_BoltComputationRequest = Map.fromList [(1,("name",T.T_STRING)),(2,("instances",T.T_I64)),(3,("cpus",T.T_DOUBLE)),(4,("mem",T.T_I64)),(5,("disk",T.T_I64)),(6,("taskHelper",(T.T_STRUCT typemap_ExecutorTaskInfoHelper))),(7,("forceUpdateBinary",T.T_BOOL)),(8,("slug",T.T_STRING))]
default_BoltComputationRequest :: BoltComputationRequest
default_BoltComputationRequest = BoltComputationRequest{
  boltComputationRequest_name = "",
  boltComputationRequest_instances = 1,
  boltComputationRequest_cpus = 0.1,
  boltComputationRequest_mem = 2048,
  boltComputationRequest_disk = 10240,
  boltComputationRequest_taskHelper = default_ExecutorTaskInfoHelper,
  boltComputationRequest_forceUpdateBinary = P.False,
  boltComputationRequest_slug = ""}
