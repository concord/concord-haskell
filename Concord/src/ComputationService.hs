{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.2)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module ComputationService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Bolt_Types
import qualified ComputationService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data Init_args = Init_args deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Init_args where
  hashWithSalt salt record = salt
instance QC.Arbitrary Init_args where
  arbitrary = QC.elements [Init_args]
from_Init_args :: Init_args -> T.ThriftVal
from_Init_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_Init_args :: (T.Protocol p, T.Transport t) => p t -> Init_args -> P.IO ()
write_Init_args oprot record = T.writeVal oprot $ from_Init_args record
encode_Init_args :: (T.Protocol p, T.Transport t) => p t -> Init_args -> LBS.ByteString
encode_Init_args oprot record = T.serializeVal oprot $ from_Init_args record
to_Init_args :: T.ThriftVal -> Init_args
to_Init_args (T.TStruct fields) = Init_args{

  }
to_Init_args _ = P.error "not a struct"
read_Init_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Init_args
read_Init_args iprot = to_Init_args <$> T.readVal iprot (T.T_STRUCT typemap_Init_args)
decode_Init_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Init_args
decode_Init_args iprot bs = to_Init_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Init_args) bs
typemap_Init_args :: T.TypeMap
typemap_Init_args = Map.fromList []
default_Init_args :: Init_args
default_Init_args = Init_args{
}
data Init_result = Init_result  { init_result_success :: ComputationTx
  , init_result_e :: P.Maybe BoltError
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Init_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` init_result_success record   `H.hashWithSalt` init_result_e record
instance QC.Arbitrary Init_result where
  arbitrary = M.liftM Init_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Init_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Init_result{init_result_success = init_result_success obj} then P.Nothing else P.Just $ default_Init_result{init_result_success = init_result_success obj}
    , if obj == default_Init_result{init_result_e = init_result_e obj} then P.Nothing else P.Just $ default_Init_result{init_result_e = init_result_e obj}
    ]
from_Init_result :: Init_result -> T.ThriftVal
from_Init_result record = T.TStruct $ Map.fromList
  (let exns = M.catMaybes [ (\_v242 -> (1, ("e",from_BoltError _v242))) <$> init_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v242 -> P.Just (0, ("success",from_ComputationTx _v242))) $ init_result_success record
    , (\_v242 -> (1, ("e",from_BoltError _v242))) <$> init_result_e record
    ]
    )
write_Init_result :: (T.Protocol p, T.Transport t) => p t -> Init_result -> P.IO ()
write_Init_result oprot record = T.writeVal oprot $ from_Init_result record
encode_Init_result :: (T.Protocol p, T.Transport t) => p t -> Init_result -> LBS.ByteString
encode_Init_result oprot record = T.serializeVal oprot $ from_Init_result record
to_Init_result :: T.ThriftVal -> Init_result
to_Init_result (T.TStruct fields) = Init_result{
  init_result_success = P.maybe (init_result_success default_Init_result) (\(_,_val244) -> (case _val244 of {T.TStruct _val245 -> (to_ComputationTx (T.TStruct _val245)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  init_result_e = P.maybe (P.Nothing) (\(_,_val244) -> P.Just (case _val244 of {T.TStruct _val246 -> (to_BoltError (T.TStruct _val246)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Init_result _ = P.error "not a struct"
read_Init_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Init_result
read_Init_result iprot = to_Init_result <$> T.readVal iprot (T.T_STRUCT typemap_Init_result)
decode_Init_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Init_result
decode_Init_result iprot bs = to_Init_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Init_result) bs
typemap_Init_result :: T.TypeMap
typemap_Init_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ComputationTx))),(1,("e",(T.T_STRUCT typemap_BoltError)))]
default_Init_result :: Init_result
default_Init_result = Init_result{
  init_result_success = default_ComputationTx,
  init_result_e = P.Nothing}
data BoltProcessRecords_args = BoltProcessRecords_args  { boltProcessRecords_args_records :: (Vector.Vector Record)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable BoltProcessRecords_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` boltProcessRecords_args_records record
instance QC.Arbitrary BoltProcessRecords_args where
  arbitrary = M.liftM BoltProcessRecords_args (QC.arbitrary)
  shrink obj | obj == default_BoltProcessRecords_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BoltProcessRecords_args{boltProcessRecords_args_records = boltProcessRecords_args_records obj} then P.Nothing else P.Just $ default_BoltProcessRecords_args{boltProcessRecords_args_records = boltProcessRecords_args_records obj}
    ]
from_BoltProcessRecords_args :: BoltProcessRecords_args -> T.ThriftVal
from_BoltProcessRecords_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v249 -> P.Just (1, ("records",T.TList (T.T_STRUCT typemap_Record) $ P.map (\_v251 -> from_Record _v251) $ Vector.toList _v249))) $ boltProcessRecords_args_records record
  ]
write_BoltProcessRecords_args :: (T.Protocol p, T.Transport t) => p t -> BoltProcessRecords_args -> P.IO ()
write_BoltProcessRecords_args oprot record = T.writeVal oprot $ from_BoltProcessRecords_args record
encode_BoltProcessRecords_args :: (T.Protocol p, T.Transport t) => p t -> BoltProcessRecords_args -> LBS.ByteString
encode_BoltProcessRecords_args oprot record = T.serializeVal oprot $ from_BoltProcessRecords_args record
to_BoltProcessRecords_args :: T.ThriftVal -> BoltProcessRecords_args
to_BoltProcessRecords_args (T.TStruct fields) = BoltProcessRecords_args{
  boltProcessRecords_args_records = P.maybe (boltProcessRecords_args_records default_BoltProcessRecords_args) (\(_,_val253) -> (case _val253 of {T.TList _ _val254 -> (Vector.fromList $ P.map (\_v255 -> (case _v255 of {T.TStruct _val256 -> (to_Record (T.TStruct _val256)); _ -> P.error "wrong type"})) _val254); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_BoltProcessRecords_args _ = P.error "not a struct"
read_BoltProcessRecords_args :: (T.Transport t, T.Protocol p) => p t -> P.IO BoltProcessRecords_args
read_BoltProcessRecords_args iprot = to_BoltProcessRecords_args <$> T.readVal iprot (T.T_STRUCT typemap_BoltProcessRecords_args)
decode_BoltProcessRecords_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> BoltProcessRecords_args
decode_BoltProcessRecords_args iprot bs = to_BoltProcessRecords_args $ T.deserializeVal iprot (T.T_STRUCT typemap_BoltProcessRecords_args) bs
typemap_BoltProcessRecords_args :: T.TypeMap
typemap_BoltProcessRecords_args = Map.fromList [(1,("records",(T.T_LIST (T.T_STRUCT typemap_Record))))]
default_BoltProcessRecords_args :: BoltProcessRecords_args
default_BoltProcessRecords_args = BoltProcessRecords_args{
  boltProcessRecords_args_records = Vector.empty}
data BoltProcessRecords_result = BoltProcessRecords_result  { boltProcessRecords_result_success :: (Vector.Vector ComputationTx)
  , boltProcessRecords_result_e :: P.Maybe BoltError
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable BoltProcessRecords_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` boltProcessRecords_result_success record   `H.hashWithSalt` boltProcessRecords_result_e record
instance QC.Arbitrary BoltProcessRecords_result where
  arbitrary = M.liftM BoltProcessRecords_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_BoltProcessRecords_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BoltProcessRecords_result{boltProcessRecords_result_success = boltProcessRecords_result_success obj} then P.Nothing else P.Just $ default_BoltProcessRecords_result{boltProcessRecords_result_success = boltProcessRecords_result_success obj}
    , if obj == default_BoltProcessRecords_result{boltProcessRecords_result_e = boltProcessRecords_result_e obj} then P.Nothing else P.Just $ default_BoltProcessRecords_result{boltProcessRecords_result_e = boltProcessRecords_result_e obj}
    ]
from_BoltProcessRecords_result :: BoltProcessRecords_result -> T.ThriftVal
from_BoltProcessRecords_result record = T.TStruct $ Map.fromList
  (let exns = M.catMaybes [ (\_v259 -> (1, ("e",from_BoltError _v259))) <$> boltProcessRecords_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v259 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_ComputationTx) $ P.map (\_v261 -> from_ComputationTx _v261) $ Vector.toList _v259))) $ boltProcessRecords_result_success record
    , (\_v259 -> (1, ("e",from_BoltError _v259))) <$> boltProcessRecords_result_e record
    ]
    )
write_BoltProcessRecords_result :: (T.Protocol p, T.Transport t) => p t -> BoltProcessRecords_result -> P.IO ()
write_BoltProcessRecords_result oprot record = T.writeVal oprot $ from_BoltProcessRecords_result record
encode_BoltProcessRecords_result :: (T.Protocol p, T.Transport t) => p t -> BoltProcessRecords_result -> LBS.ByteString
encode_BoltProcessRecords_result oprot record = T.serializeVal oprot $ from_BoltProcessRecords_result record
to_BoltProcessRecords_result :: T.ThriftVal -> BoltProcessRecords_result
to_BoltProcessRecords_result (T.TStruct fields) = BoltProcessRecords_result{
  boltProcessRecords_result_success = P.maybe (boltProcessRecords_result_success default_BoltProcessRecords_result) (\(_,_val263) -> (case _val263 of {T.TList _ _val264 -> (Vector.fromList $ P.map (\_v265 -> (case _v265 of {T.TStruct _val266 -> (to_ComputationTx (T.TStruct _val266)); _ -> P.error "wrong type"})) _val264); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  boltProcessRecords_result_e = P.maybe (P.Nothing) (\(_,_val263) -> P.Just (case _val263 of {T.TStruct _val267 -> (to_BoltError (T.TStruct _val267)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_BoltProcessRecords_result _ = P.error "not a struct"
read_BoltProcessRecords_result :: (T.Transport t, T.Protocol p) => p t -> P.IO BoltProcessRecords_result
read_BoltProcessRecords_result iprot = to_BoltProcessRecords_result <$> T.readVal iprot (T.T_STRUCT typemap_BoltProcessRecords_result)
decode_BoltProcessRecords_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> BoltProcessRecords_result
decode_BoltProcessRecords_result iprot bs = to_BoltProcessRecords_result $ T.deserializeVal iprot (T.T_STRUCT typemap_BoltProcessRecords_result) bs
typemap_BoltProcessRecords_result :: T.TypeMap
typemap_BoltProcessRecords_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_ComputationTx)))),(1,("e",(T.T_STRUCT typemap_BoltError)))]
default_BoltProcessRecords_result :: BoltProcessRecords_result
default_BoltProcessRecords_result = BoltProcessRecords_result{
  boltProcessRecords_result_success = Vector.empty,
  boltProcessRecords_result_e = P.Nothing}
data BoltProcessTimer_args = BoltProcessTimer_args  { boltProcessTimer_args_key :: LT.Text
  , boltProcessTimer_args_time :: I.Int64
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable BoltProcessTimer_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` boltProcessTimer_args_key record   `H.hashWithSalt` boltProcessTimer_args_time record
instance QC.Arbitrary BoltProcessTimer_args where
  arbitrary = M.liftM BoltProcessTimer_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BoltProcessTimer_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BoltProcessTimer_args{boltProcessTimer_args_key = boltProcessTimer_args_key obj} then P.Nothing else P.Just $ default_BoltProcessTimer_args{boltProcessTimer_args_key = boltProcessTimer_args_key obj}
    , if obj == default_BoltProcessTimer_args{boltProcessTimer_args_time = boltProcessTimer_args_time obj} then P.Nothing else P.Just $ default_BoltProcessTimer_args{boltProcessTimer_args_time = boltProcessTimer_args_time obj}
    ]
from_BoltProcessTimer_args :: BoltProcessTimer_args -> T.ThriftVal
from_BoltProcessTimer_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v270 -> P.Just (1, ("key",T.TString $ E.encodeUtf8 _v270))) $ boltProcessTimer_args_key record
  , (\_v270 -> P.Just (2, ("time",T.TI64 _v270))) $ boltProcessTimer_args_time record
  ]
write_BoltProcessTimer_args :: (T.Protocol p, T.Transport t) => p t -> BoltProcessTimer_args -> P.IO ()
write_BoltProcessTimer_args oprot record = T.writeVal oprot $ from_BoltProcessTimer_args record
encode_BoltProcessTimer_args :: (T.Protocol p, T.Transport t) => p t -> BoltProcessTimer_args -> LBS.ByteString
encode_BoltProcessTimer_args oprot record = T.serializeVal oprot $ from_BoltProcessTimer_args record
to_BoltProcessTimer_args :: T.ThriftVal -> BoltProcessTimer_args
to_BoltProcessTimer_args (T.TStruct fields) = BoltProcessTimer_args{
  boltProcessTimer_args_key = P.maybe (boltProcessTimer_args_key default_BoltProcessTimer_args) (\(_,_val272) -> (case _val272 of {T.TString _val273 -> E.decodeUtf8 _val273; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  boltProcessTimer_args_time = P.maybe (boltProcessTimer_args_time default_BoltProcessTimer_args) (\(_,_val272) -> (case _val272 of {T.TI64 _val274 -> _val274; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_BoltProcessTimer_args _ = P.error "not a struct"
read_BoltProcessTimer_args :: (T.Transport t, T.Protocol p) => p t -> P.IO BoltProcessTimer_args
read_BoltProcessTimer_args iprot = to_BoltProcessTimer_args <$> T.readVal iprot (T.T_STRUCT typemap_BoltProcessTimer_args)
decode_BoltProcessTimer_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> BoltProcessTimer_args
decode_BoltProcessTimer_args iprot bs = to_BoltProcessTimer_args $ T.deserializeVal iprot (T.T_STRUCT typemap_BoltProcessTimer_args) bs
typemap_BoltProcessTimer_args :: T.TypeMap
typemap_BoltProcessTimer_args = Map.fromList [(1,("key",T.T_STRING)),(2,("time",T.T_I64))]
default_BoltProcessTimer_args :: BoltProcessTimer_args
default_BoltProcessTimer_args = BoltProcessTimer_args{
  boltProcessTimer_args_key = "",
  boltProcessTimer_args_time = 0}
data BoltProcessTimer_result = BoltProcessTimer_result  { boltProcessTimer_result_success :: ComputationTx
  , boltProcessTimer_result_e :: P.Maybe BoltError
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable BoltProcessTimer_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` boltProcessTimer_result_success record   `H.hashWithSalt` boltProcessTimer_result_e record
instance QC.Arbitrary BoltProcessTimer_result where
  arbitrary = M.liftM BoltProcessTimer_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_BoltProcessTimer_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BoltProcessTimer_result{boltProcessTimer_result_success = boltProcessTimer_result_success obj} then P.Nothing else P.Just $ default_BoltProcessTimer_result{boltProcessTimer_result_success = boltProcessTimer_result_success obj}
    , if obj == default_BoltProcessTimer_result{boltProcessTimer_result_e = boltProcessTimer_result_e obj} then P.Nothing else P.Just $ default_BoltProcessTimer_result{boltProcessTimer_result_e = boltProcessTimer_result_e obj}
    ]
from_BoltProcessTimer_result :: BoltProcessTimer_result -> T.ThriftVal
from_BoltProcessTimer_result record = T.TStruct $ Map.fromList
  (let exns = M.catMaybes [ (\_v277 -> (1, ("e",from_BoltError _v277))) <$> boltProcessTimer_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v277 -> P.Just (0, ("success",from_ComputationTx _v277))) $ boltProcessTimer_result_success record
    , (\_v277 -> (1, ("e",from_BoltError _v277))) <$> boltProcessTimer_result_e record
    ]
    )
write_BoltProcessTimer_result :: (T.Protocol p, T.Transport t) => p t -> BoltProcessTimer_result -> P.IO ()
write_BoltProcessTimer_result oprot record = T.writeVal oprot $ from_BoltProcessTimer_result record
encode_BoltProcessTimer_result :: (T.Protocol p, T.Transport t) => p t -> BoltProcessTimer_result -> LBS.ByteString
encode_BoltProcessTimer_result oprot record = T.serializeVal oprot $ from_BoltProcessTimer_result record
to_BoltProcessTimer_result :: T.ThriftVal -> BoltProcessTimer_result
to_BoltProcessTimer_result (T.TStruct fields) = BoltProcessTimer_result{
  boltProcessTimer_result_success = P.maybe (boltProcessTimer_result_success default_BoltProcessTimer_result) (\(_,_val279) -> (case _val279 of {T.TStruct _val280 -> (to_ComputationTx (T.TStruct _val280)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  boltProcessTimer_result_e = P.maybe (P.Nothing) (\(_,_val279) -> P.Just (case _val279 of {T.TStruct _val281 -> (to_BoltError (T.TStruct _val281)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_BoltProcessTimer_result _ = P.error "not a struct"
read_BoltProcessTimer_result :: (T.Transport t, T.Protocol p) => p t -> P.IO BoltProcessTimer_result
read_BoltProcessTimer_result iprot = to_BoltProcessTimer_result <$> T.readVal iprot (T.T_STRUCT typemap_BoltProcessTimer_result)
decode_BoltProcessTimer_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> BoltProcessTimer_result
decode_BoltProcessTimer_result iprot bs = to_BoltProcessTimer_result $ T.deserializeVal iprot (T.T_STRUCT typemap_BoltProcessTimer_result) bs
typemap_BoltProcessTimer_result :: T.TypeMap
typemap_BoltProcessTimer_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ComputationTx))),(1,("e",(T.T_STRUCT typemap_BoltError)))]
default_BoltProcessTimer_result :: BoltProcessTimer_result
default_BoltProcessTimer_result = BoltProcessTimer_result{
  boltProcessTimer_result_success = default_ComputationTx,
  boltProcessTimer_result_e = P.Nothing}
data BoltMetadata_args = BoltMetadata_args deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable BoltMetadata_args where
  hashWithSalt salt record = salt
instance QC.Arbitrary BoltMetadata_args where
  arbitrary = QC.elements [BoltMetadata_args]
from_BoltMetadata_args :: BoltMetadata_args -> T.ThriftVal
from_BoltMetadata_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_BoltMetadata_args :: (T.Protocol p, T.Transport t) => p t -> BoltMetadata_args -> P.IO ()
write_BoltMetadata_args oprot record = T.writeVal oprot $ from_BoltMetadata_args record
encode_BoltMetadata_args :: (T.Protocol p, T.Transport t) => p t -> BoltMetadata_args -> LBS.ByteString
encode_BoltMetadata_args oprot record = T.serializeVal oprot $ from_BoltMetadata_args record
to_BoltMetadata_args :: T.ThriftVal -> BoltMetadata_args
to_BoltMetadata_args (T.TStruct fields) = BoltMetadata_args{

  }
to_BoltMetadata_args _ = P.error "not a struct"
read_BoltMetadata_args :: (T.Transport t, T.Protocol p) => p t -> P.IO BoltMetadata_args
read_BoltMetadata_args iprot = to_BoltMetadata_args <$> T.readVal iprot (T.T_STRUCT typemap_BoltMetadata_args)
decode_BoltMetadata_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> BoltMetadata_args
decode_BoltMetadata_args iprot bs = to_BoltMetadata_args $ T.deserializeVal iprot (T.T_STRUCT typemap_BoltMetadata_args) bs
typemap_BoltMetadata_args :: T.TypeMap
typemap_BoltMetadata_args = Map.fromList []
default_BoltMetadata_args :: BoltMetadata_args
default_BoltMetadata_args = BoltMetadata_args{
}
data BoltMetadata_result = BoltMetadata_result  { boltMetadata_result_success :: ComputationMetadata
  , boltMetadata_result_e :: P.Maybe BoltError
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable BoltMetadata_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` boltMetadata_result_success record   `H.hashWithSalt` boltMetadata_result_e record
instance QC.Arbitrary BoltMetadata_result where
  arbitrary = M.liftM BoltMetadata_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_BoltMetadata_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BoltMetadata_result{boltMetadata_result_success = boltMetadata_result_success obj} then P.Nothing else P.Just $ default_BoltMetadata_result{boltMetadata_result_success = boltMetadata_result_success obj}
    , if obj == default_BoltMetadata_result{boltMetadata_result_e = boltMetadata_result_e obj} then P.Nothing else P.Just $ default_BoltMetadata_result{boltMetadata_result_e = boltMetadata_result_e obj}
    ]
from_BoltMetadata_result :: BoltMetadata_result -> T.ThriftVal
from_BoltMetadata_result record = T.TStruct $ Map.fromList
  (let exns = M.catMaybes [ (\_v289 -> (1, ("e",from_BoltError _v289))) <$> boltMetadata_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v289 -> P.Just (0, ("success",from_ComputationMetadata _v289))) $ boltMetadata_result_success record
    , (\_v289 -> (1, ("e",from_BoltError _v289))) <$> boltMetadata_result_e record
    ]
    )
write_BoltMetadata_result :: (T.Protocol p, T.Transport t) => p t -> BoltMetadata_result -> P.IO ()
write_BoltMetadata_result oprot record = T.writeVal oprot $ from_BoltMetadata_result record
encode_BoltMetadata_result :: (T.Protocol p, T.Transport t) => p t -> BoltMetadata_result -> LBS.ByteString
encode_BoltMetadata_result oprot record = T.serializeVal oprot $ from_BoltMetadata_result record
to_BoltMetadata_result :: T.ThriftVal -> BoltMetadata_result
to_BoltMetadata_result (T.TStruct fields) = BoltMetadata_result{
  boltMetadata_result_success = P.maybe (boltMetadata_result_success default_BoltMetadata_result) (\(_,_val291) -> (case _val291 of {T.TStruct _val292 -> (to_ComputationMetadata (T.TStruct _val292)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  boltMetadata_result_e = P.maybe (P.Nothing) (\(_,_val291) -> P.Just (case _val291 of {T.TStruct _val293 -> (to_BoltError (T.TStruct _val293)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_BoltMetadata_result _ = P.error "not a struct"
read_BoltMetadata_result :: (T.Transport t, T.Protocol p) => p t -> P.IO BoltMetadata_result
read_BoltMetadata_result iprot = to_BoltMetadata_result <$> T.readVal iprot (T.T_STRUCT typemap_BoltMetadata_result)
decode_BoltMetadata_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> BoltMetadata_result
decode_BoltMetadata_result iprot bs = to_BoltMetadata_result $ T.deserializeVal iprot (T.T_STRUCT typemap_BoltMetadata_result) bs
typemap_BoltMetadata_result :: T.TypeMap
typemap_BoltMetadata_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ComputationMetadata))),(1,("e",(T.T_STRUCT typemap_BoltError)))]
default_BoltMetadata_result :: BoltMetadata_result
default_BoltMetadata_result = BoltMetadata_result{
  boltMetadata_result_success = default_ComputationMetadata,
  boltMetadata_result_e = P.Nothing}
process_init (seqid, iprot, oprot, handler) = do
  args <- read_Init_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.init handler
        let res = default_Init_result{init_result_success = val}
        T.writeMessageBegin oprot ("init", T.M_REPLY, seqid)
        write_Init_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Init_result{init_result_e = P.Just e}
        T.writeMessageBegin oprot ("init", T.M_REPLY, seqid)
        write_Init_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("init", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_boltProcessRecords (seqid, iprot, oprot, handler) = do
  args <- read_BoltProcessRecords_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.boltProcessRecords handler (boltProcessRecords_args_records args)
        let res = default_BoltProcessRecords_result{boltProcessRecords_result_success = val}
        T.writeMessageBegin oprot ("boltProcessRecords", T.M_REPLY, seqid)
        write_BoltProcessRecords_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_BoltProcessRecords_result{boltProcessRecords_result_e = P.Just e}
        T.writeMessageBegin oprot ("boltProcessRecords", T.M_REPLY, seqid)
        write_BoltProcessRecords_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("boltProcessRecords", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_boltProcessTimer (seqid, iprot, oprot, handler) = do
  args <- read_BoltProcessTimer_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.boltProcessTimer handler (boltProcessTimer_args_key args) (boltProcessTimer_args_time args)
        let res = default_BoltProcessTimer_result{boltProcessTimer_result_success = val}
        T.writeMessageBegin oprot ("boltProcessTimer", T.M_REPLY, seqid)
        write_BoltProcessTimer_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_BoltProcessTimer_result{boltProcessTimer_result_e = P.Just e}
        T.writeMessageBegin oprot ("boltProcessTimer", T.M_REPLY, seqid)
        write_BoltProcessTimer_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("boltProcessTimer", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_boltMetadata (seqid, iprot, oprot, handler) = do
  args <- read_BoltMetadata_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.boltMetadata handler
        let res = default_BoltMetadata_result{boltMetadata_result_success = val}
        T.writeMessageBegin oprot ("boltMetadata", T.M_REPLY, seqid)
        write_BoltMetadata_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_BoltMetadata_result{boltMetadata_result_e = P.Just e}
        T.writeMessageBegin oprot ("boltMetadata", T.M_REPLY, seqid)
        write_BoltMetadata_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("boltMetadata", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "init" -> process_init (seqid,iprot,oprot,handler)
  "boltProcessRecords" -> process_boltProcessRecords (seqid,iprot,oprot,handler)
  "boltProcessTimer" -> process_boltProcessTimer (seqid,iprot,oprot,handler)
  "boltMetadata" -> process_boltMetadata (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessageBegin oprot (name,T.M_EXCEPTION,seqid)
    T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
    T.writeMessageEnd oprot
    T.tFlush (T.getTransport oprot)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- T.readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  T.readMessageEnd iprot
  P.return P.True
